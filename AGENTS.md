## GPT's IDEA
```
Skip to content
Chat history

You said:
다음을 보고 해커톤 아이디어를 소개해주세요

# Qwen SKYST Hackathon on Base by FLock.io

### FLock.io

> [FLock.io](http://flock.io/) is the first decentralized AI training platform combining Federated Learning and blockchain to enable secure, privacy-preserving model training. It empowers communities to collaboratively build and own AI without centralizing data. Powered by the $FLOCK token, FLock drives governance, incentives, and ecosystem growth. Backed by top investors and the Ethereum Foundation, it’s reshaping AI’s future.
> 

🔗 [Website](https://www.flock.io/) | [Telegram](https://t.me/flock_io_community/80750) |  [Twitter](https://x.com/flock_io)  

## **Base**

> Base is an Ethereum Layer-2 blockchain network developed by Coinbase. It is designed to improve scalability, performance, and interoperability while reducing transaction costs and settlement time on the Ethereum network. As a decentralized platform, Base supports a wide range of dApps and smart contracts.
> 

🔗 [Website](https://www.base.org/) | [Telegram](https://t.me/daehanbase) |  [Twitter](https://x.com/daehan_base)  

### Qwen

> Qwen is a family of large language models developed by Alibaba Cloud. Built to understand and generate both Chinese and English, Qwen is designed for a wide range of applications including natural language processing, reasoning, and multimodal tasks. As an open and scalable AI foundation, Qwen powers chatbots, coding assistants, and enterprise solutions across Alibaba’s ecosystem and beyond.
> 

🔗 [Website](https://qwen.ai/home) | [Linkedin](https://www.linkedin.com/company/qwen) |  [Twitter](https://x.com/Alibaba_Qwen)  

## **🟦** Qwen SKYST Hackathon on Base 개요

Qwen SKYST Hackathon on Base는 Base의 가장 큰 AI 인프라 프로토콜인 FLock.io와 Alibaba Cloud의 Qwen이 Base와 협력하여 주최하는 AI 어플리케이션 해커톤입니다.

베이스의 다채로운 어플리케이션 생태계를 활성화하기 위해서 앱 빌더들을 지원하고 커뮤니티와 공유할 수 있는 기회입니다. 이전 Qwen SKYST Hackathon은 AI 모델을 만드는 데이터톤이었다면, 이번 해커톤은 해당 모델들을 활용하여 실제로 유저들이 활용 가능한 어플리케이션을 Base Mini App 형태로 혹은 x402를 활용한 어플리케이션/AI Agent를 만드는 해커톤입니다.

**총 진행 기간:** 2025년 11월 21일 - 11월 29일 

**해커톤 주제 1: Build an AI Application utilizing FLock.io’s API Platform as a Base Mini App**

**해커톤 주제 2: Build an AI Application utilizing FLock.io’s API Platform and x402**

## **🟦**  해커톤 소개 및 참가 방법 안내

### 🪧 ****해커톤 안내

타임라인

- 접수 기간: 11월13일 ~ 11월 22일 (선착순 100명 내외로 제한되어 조기 마감될 수 있습니다)
- API 지급: 11월 21일 ~ 11월 23일
- 킥오프: 11월 22일 오후 1시~3시
    - 진행: 온라인(상황에 따라 녹화본 배포로 변경될 수 있음)
- 온라인 해커톤 진행: 11월 22일~11월 28일 오후 6시
    - 제출 마감 기한은 11월 28일 오후 6시
    - 해커톤 플랫폼 및 결과물 제출 방법은 추후 공지 예정
- Top 8 발표 팀 선정: 11월 28일 자정
- 발표 및 최종 시상식: 11월 29일(토) 오후 2시 ~ 6시

총 상금: $15K

| 등수 | 상금 |
| --- | --- |
| 1 | $5000 |
| 2 | $3000 |
| 3 | $2000 |
| Finalist (4~8) | $1000 |

### 📝 해커톤 참가 신청서

[Qwen SKYST Hackathon on Base 신청서](https://forms.gle/nB6cvYkyJknujBof6)

한 팀은 총 1~3명으로 구성됩니다

### 💡 해커톤 주제

✅ 필수 조건

1. FLock.io의 [API Platform](https://docs.flock.io/flock-products/api-platform/getting-started)의 API를 이용 (OpenAI API 사용하는것과 유사)
2. 다음중 두가지 중에서 하나를 충족
    1. [Base Mini App](https://docs.base.org/mini-apps/quickstart/create-new-miniapp) 만들기 
    2. [x402](https://www.coinbase.com/developer-platform/products/x402) 활용한 어플리케이션 혹은 AI Agent 만들기

킥오프에 해당 API 등을 사용하기 위한 간단한 Vibe coding session이 진행될 예정입니다

참고 예시: Vibe Master by [FLock.io](http://FLock.io)

- [데모 영상](https://x.com/0x7SUN/status/1984020009992253749?s=20)
- [웹사이트](https://vibe.flock.io/login)

✔️ 평가 항목

- 완성도 (30%)
- FLock API 활용도 (30%)
- 창의성 (20%)
- 실용성 (20%)

**제출 자료:**

1. 5분 이내의 프로젝트 설명 및 데모 (영상)
2. 프로젝트 소개 슬라이드, 팀 구성원 소개 (PDF)
3. 프로젝트 설명 (추후 양식 공개 예정)

## **🟦**  행사 정보

---

해커톤 데모데이 발표 및 시상식 일정: 2025년 11월 29일(토) 오후 2시 ~ 6시

장소: 드림플러스 강남 지하 1층

주최: FLock.io, Base, Alibaba Cloud

참가 대상: Base 및 AI 어플리케이션 개발에 관심 있는 학생, 개발자, 컨텐츠 제작자 등

### 데모데이 타임라인

14:00~14:30 Registration

14:30~14:45 Closing remarks by [FLock.io](http://FLock.io) (Jiahao Sun, CEO)

14:45~15:00 Closing remarks by Base (David, Head of East Asia)

15:00~15:15 Closing remarks by Alibaba Cloud (Stone, Head of Business Development)

15:15~16:30 Top 8 Team 데모 발표

16:30~17:00 Break Time 및 Top Team 최종 심사

17:00~17:15 우승자 발표 및 시상식

17:15~18:00 Networking


----------

예를 들어 https://github.com/tursodatabase/agentfs 이런걸 활용한다거나 

다양한 아이디어를 아주 기술적으로 자세하게 만들어보세요
ChatGPT said:
Qwen SKYST Hackathon on Base에 참가하기 위한 해커톤 아이디어를 제안드리겠습니다. 아이디어를 구성하는 데 있어 다음 요소들을 알려주시면 더 정교한 제안을 드릴 수 있습니다:

관심 있는 분야나 문제 영역이 있으신가요? (예: 교육, 금융, 창작 도구, 헬스케어 등)

팀 규모는 어떻게 되시나요? (개인, 2인, 3인)

Vibe Master 같은 사례처럼 멀티모달 기능이나 에이전트형 AI를 선호하시나요?

AI 사용자는 일반 유저인가요, 개발자/전문가인가요?

agentfs, LangChain, x402 등 기술 스택 관련하여 선호하거나 이미 익숙한 게 있으신가요?

이런 내용을 알려주시면 FLock API, Base Mini App 혹은 x402 기반으로 더 기술적으로 상세한 해커톤 아이디어를 설계해드릴 수 있습니다!

You said:
아래 내용에 집중
-----------------------------------------------------------------------------
다음을 활용하여:
### 💡 해커톤 주제

✅ 필수 조건

1. FLock.io의 [API Platform](https://docs.flock.io/flock-products/api-platform/getting-started)의 API를 이용 (OpenAI API 사용하는것과 유사)
2. 다음중 두가지 중에서 하나를 충족
    1. [Base Mini App](https://docs.base.org/mini-apps/quickstart/create-new-miniapp) 만들기 
    2. [x402](https://www.coinbase.com/developer-platform/products/x402) 활용한 어플리케이션 혹은 AI Agent 만들기

킥오프에 해당 API 등을 사용하기 위한 간단한 Vibe coding session이 진행될 예정입니다

예를 들어 https://github.com/tursodatabase/agentfs 이런걸 활용한다거나 

약 3-5개 정도 아이디어를 아주 기술적으로 자세하게 만들어보세요
ChatGPT said:
좋습니다. FLock.io의 API 플랫폼과 Base Mini App 혹은 x402 기반을 활용하여 기술적으로 구체화된 AI 어플리케이션 아이디어를 3~5가지 설계해보겠습니다. 각 아이디어는 예시로 주신 agentfs 스타일의 에이전트 연동도 고려하며, 실현 가능성과 창의성을 반영하겠습니다.

완성되는 대로 바로 알려드리겠습니다. 그동안 궁금하신 점 있으시면 편하게 말씀해주세요!

Research completed in 9m · 12 sources · 31 searches
Qwen SKYST Hackathon: 기술 아이디어 제안
Qwen SKYST Hackathon on Base는 FLock.io의 AI 인프라와 Alibaba Cloud의 Qwen 모델을 활용하여 혁신적인 AI 어플리케이션을 개발하는 해커톤입니다. 아래 필수 조건(FLock.io의 API 플랫폼 활용 및 Base Mini App 또는 x402 적용)을 모두 만족하면서도 완성도, 창의성, 실용성을 갖춘 3~5개의 기술적 아이디어를 제안합니다. 각 아이디어는 FLock.io의 분산 AI 플랫폼과 Qwen 모델의 성능을 적극 활용하고, Base L2와 x402 프로토콜을 통합하여 블록체인 기반의 새로운 AI 서비스를 구현합니다.
아이디어 1: 베이스 미니앱 기반 프라이버시 보호 의료 AI 비서
개요: 환자 데이터 프라이버시를 지키면서 의료 조언을 제공하는 AI 비서입니다. 사용자의 의료 데이터는 중앙 서버에 업로드하지 않고, FLock.io의 Federated Learning을 통해 로컬에서 모델 학습에 활용됩니다. 최종 AI 모델(예: Alibaba Cloud의 Qwen)은 병원이나 개인 기기에서 분산 학습되어 의료 지식이 향상되고, Base Mini App으로 구현된 프런트엔드에서 환자와 의사가 AI 비서와 상호작용합니다.
FLock API 활용: FLock의 API 플랫폼을 통해 OpenAI API처럼 손쉽게 의료 특화 언어모델에 질의응답을 수행합니다
docs.flock.io
. 예를 들어 “증상으로 가능한 진단은?”과 같은 질문에 Qwen 기반 모델이 의료 지식을 바탕으로 답변을 생성합니다. 모델 학습은 환자들의 민감한 데이터를 보호하기 위해 연합 학습(Federated Learning) 방식으로 진행됩니다. 각 의료 기관은 FLock의 노드를 통해 자체 데이터를 사용해 모델을 부분 학습하고, 중앙 서버에는 모델 파라미터만 공유되어 개인정보 없이 전역 모델을 향상시킵니다.
Base Mini App 구현: 최종 사용자 인터페이스는 Coinbase 지갑의 Base Mini App으로 제공됩니다. 의사와 환자는 Coinbase Wallet 또는 Base 앱 내의 Mini App에서 AI 비서에 질문을 하고 답변을 얻습니다. Mini App은 Base 계정을 통해 사용자 인증을 처리하고, 스마트 컨트랙트를 이용해 사용자 별 접근 권한(예: 환자 자신의 데이터에 대한 질의만 가능)을 관리합니다.
기술 스택 및 구성: 프런트엔드는 React/Next.js 기반 Mini App 템플릿을 활용하여 개발하고, 후방에서는 FLock API 서버와 통신합니다. Base 체인 상의 스마트 컨트랙트는 환자 데이터 접근 권한과 연합 학습 참여 인센티브(예: 데이터 제공 병원에 토큰 보상)를 관리합니다. FLock API 호출 시 필요한 인증 토큰과 사용량 추적은 FLock 플랫폼에서 제공하는 대시보드를 활용하여 모니터링합니다.
특징 및 기대 효과: 이 아이디어는 의료 도메인에 특화된 Qwen 모델을 활용하여 높은 정확도의 답변을 제공하면서도, 데이터 프라이버시를 지키는 것이 핵심입니다. 연합 학습으로 개별 병원의 데이터를 안전하게 활용하므로 실용성과 완성도 점수를 높일 수 있습니다. 또한 Base 체인과 연계된 투명한 데이터 사용 이력, 토큰 보상 체계로 의료 AI 생태계 참여자들에게 창의적인 인센티브를 제공합니다.
아이디어 2: x402 + AgentFS 기반 자율 DeFi 투자 에이전트
개요: 탈중앙화 금융(DeFi) 시장에서 자동으로 투자 전략을 실행하는 자율 에이전트입니다. 이 에이전트는 FLock.io의 AI 모델(Qwen 등)을 통해 시장 상황을 분석하고 의사결정을 내리며, AgentFS 파일시스템을 활용해 모든 상태와 행동을 로컬 SQLite DB에 기록합니다. 또한 x402 프로토콜을 통해 실시간 데이터/API에 대한 요금 결제를 자동화하여, 에이전트가 필요할 때 외부 서비스를 스스로 지불하고 이용할 수 있습니다
coinbase.com
.
FLock AI 의사결정: 에이전트는 FLock API로 제공되는 Qwen 기반 대형언어모델을 활용하여 DeFi 시장 데이터에 대한 분석과 추론을 수행합니다. 예를 들어 현재 Yield Farming 이자율, 토큰 가격 변동, 사용자 자산 포트폴리오를 종합적으로 고려해 “지금 어떤 풀에 예치할지”를 결정합니다. FLock API는 OpenAI와 호환되는 인터페이스이므로 챗봇 형태로 프롬프트를 구성해 에이전트의 의사결정 과정을 제어합니다
docs.flock.io
.
AgentFS로 상태 관리: 에이전트의 메모리와 활동 내역은 AgentFS를 통해 관리됩니다. AgentFS는 AI 에이전트를 위한 특수 파일시스템으로, 모든 파일, 상태, 툴 사용 기록을 하나의 SQLite 데이터베이스에 저장합니다
github.com
. 이를 통해 에이전트가 수행한 과거 트랜잭션, 시장 데이터 캐시, 의사결정 근거(프롬프트와 모델 응답)를 모두 기록하여 추적 가능성과 재현성을 확보합니다
github.com
. 개발자는 이 SQLite 로그를 SQL로 질의하여 에이전트의 의사결정 경향을 분석하거나 오류 발생 시 디버깅에 활용할 수 있습니다.
x402 자율 결제: 에이전트는 외부 데이터 소스나 프리미엄 API(예: 고급 차트 데이터, 예측 모델 API 등)에 접근할 때 x402 프로토콜을 사용해 마이크로페이먼트를 처리합니다. x402는 HTTP 상에서 동작하는 인터넷 네이티브 결제 프로토콜로, API 호출당 과금 등의 시나리오를 지원합니다
coinbase.com
. 예를 들어 에이전트가 어떤 가격 예측 API를 호출하면 서버가 HTTP 402 Payment Required 응답을 보낼 수 있고, 에이전트는 x402를 통해 즉시 USDC 지불을 완료하고 데이터를 얻습니다. 이러한 자동 결제 기능으로 에이전트는 사람의 개입 없이 필요한 서비스를 구매하여 활용할 수 있습니다. 이는 AI 에이전트가 자율적으로 경제 활동을 하게 해주는 핵심 요소입니다.
Base 및 온체인 연계: 에이전트는 Base 체인 계정을 통해 실제 투자 실행(트랜잭션 전송)을 합니다. 사용자는 Base 상의 스마트 월렛에 에이전트를 위한 허용 범위를 설정해두면, 에이전트는 그 범위 내에서 (예: 최대 X ETH까지 투자) 자동으로 거래를 수행합니다. Chainlink의 CRE(Chainlink Runtime Environment)와 통합하면 에이전트가 on-chain 자동화 워크플로우를 트리거하고 결과를 검증받을 수도 있습니다
coinbase.com
coinbase.com
. x402는 이러한 CRE 워크플로우에도 결제를 적용해, 에이전트가 특정 데이터 피드나 자동화 서비스 사용 시 실시간으로 비용을 지불하도록 합니다.
기대 효과: 이 에이전트는 완성도(자동화 수준) 면에서 높은 평가를 받을 수 있으며, FLock API와 x402를 활용한 참신한 조합으로 창의성을 보여줍니다. AgentFS 덕분에 운용 기록이 투명하게 축적되고 오류를 추적할 수 있어 신뢰성이 높습니다. 실사용자는 복잡한 DeFi 시장에서 실시간으로 대응하는 AI 에이전트를 통해 투자 효율을 높일 수 있으며, 개발자는 AI 에이전트의 경제 활동이라는 미래 지향적인 개념을 구현해볼 수 있습니다.
아이디어 3: x402 기반 AI 서비스 마켓플레이스 (페이퍼유스)
개요: 여러 개발자나 기업이 자신만의 AI 모델(API)을 출품하고, 사용자는 필요한 AI 서비스를 **사용한 만큼만 지불(pay-per-use)**하여 이용할 수 있는 탈중앙 마켓플레이스입니다. 예를 들어 법률 상담 AI, 이미지 생성 AI, 번역 AI 등 다양한 모델이 등록되며, FLock.io의 API 플랫폼을 통해 이들 모델이 호스팅됩니다. x402 프로토콜을 통합하여 사용자가 구독 없이 API 호출당 소액결제를 수행함으로써
coinbase.com
, 서비스 제공자에게 즉각적으로 수익이 분배되는 구조를 만듭니다.
플랫폼 구성: 서비스 제공자는 FLock의 API Platform에 자신의 AI 모델(사전에 연합학습/파인튜닝된 Qwen 등)을 배포하고 API 엔드포인트를 얻습니다. 마켓플레이스는 Base L2에 스마트 컨트랙트를 통해 구현되어, 서비스 카탈로그, 이용 권한, 정산 로직을 온체인에 일부 기록합니다. 프런트엔드는 Base Mini App 또는 웹 애플리케이션으로 만들어져 Coinbase Wallet 사용자들이 직접 접근할 수 있게 합니다.
x402 결제 흐름: 사용자가 특정 AI 서비스를 호출할 때, x402 미들웨어가 결제를 처리합니다. 예를 들어 사용자가 “계약서를 요약해줘” 라는 법률 AI 서비스를 1회 호출하면, 서비스 서버는 402 Payment Required 응답을 통해 비용(예: 0.5 USDC)을 요구하고, x402 프로토콜이 즉각적인 USDC 결제를 수행합니다
coinbase.com
. 결제가 완료되면 AI API가 응답 결과를 반환하는 구조입니다. 신용카드나 중개자 없이 온체인 결제가 실시간 이루어지므로, 중간 수수료나 차지가 발생하지 않고 서비스 제공자는 곧바로 수익을 얻습니다
coinbase.com
.
FLock API 및 모델 관리: FLock.io 플랫폼은 OpenAI 호환 SDK를 제공하므로 개발자들은 친숙한 방식으로 모델 API를 구축할 수 있습니다
docs.flock.io
. 또한 FLock의 AI 마켓플레이스 기능과 연계하여, 인기있는 모델은 평판이나 토큰 보상 체계를 가질 수 있습니다. 사용 로그와 결제 내역은 Base 체인에 기록되어 투명성을 확보하고, 상위 DAO 거버넌스를 통해 사기 모델을 필터링하거나 플랫폼 업그레이드를 결정할 수도 있습니다.
기술적 고려사항: x402 통합을 위해 Coinbase에서 제공하는 x402 SDK 및 예제 템플릿을 활용합니다 (예: Express.js 서버에 미들웨어로 삽입
github.com
). 스마트 컨트랙트는 서비스 등록과 정산 규칙(예: 수수료 분배)을 담고, 모든 결제는 USDC로 처리되어 스테이블코인 기반의 안정성을 제공합니다. 또한, 서비스 품질 모니터링을 위해 FLock API 호출 성공/실패나 응답 시간을 로그하고, 일정 이상 실패율의 서비스는 자동 제외하는 기능 등을 구현해 완성도를 높입니다.
효과: 이 마켓플레이스는 실용성이 뛰어난 아이디어로, 다양한 AI 서비스에 손쉽게 접근하고 필요한 만큼만 지불하려는 수요를 만족시킵니다. FLock과 Base, x402의 결합으로 창의적인 비즈니스 모델 (탈중앙 AI API 마켓)을 선보이며, 서비스 제공자와 이용자 모두에게 새로운 가치를 제공합니다. 특히 AI API에 마이크로페이먼트를 적용한 구조는 Web3 시대의 AI 유틸리티를 보여주는 좋은 사례가 될 것입니다.
아이디어 4: Base Mini App 기반 AI 코딩 도우미 (스마트 컨트랙트 코파일럿)
개요: 스마트 컨트랙트를 작성하거나 감사(audit)하려는 개발자를 위한 AI 코딩 비서입니다. 이 도구는 Qwen 등의 대형언어모델을 활용하여 Solidity 코드 작성을 도와주거나, 보안 취약점을 리뷰해줍니다. Base Mini App 형태로 제공되어, 사용자는 지갑 내에서 바로 코딩 보조를 받을 수 있으며, 필요에 따라 x402를 통해 고급 분석(예: 정적 분석 툴 연동)을 온디맨드 결제로 사용할 수 있습니다.
FLock + Qwen을 통한 코딩 지원: 사용자가 Mini App에 Solidity 스마트 컨트랙트에 대한 요청(예: “ERC-20 토큰 코드를 생성해줘” 또는 “다음 코드를 분석해줘”)을 하면, 백엔드에서는 FLock API를 통해 Qwen 기반 코딩 모델에 프롬프트를 전달합니다. Qwen 모델은 다중 언어 및 코딩 능력이 뛰어나 복잡한 코드 생성과 설명도 가능합니다
alibabacloud.com
alibabacloud.com
. 모델의 응답으로 생성된 코드 스니펫이나 감사 리포트를 사용자에게 반환합니다. FLock API는 OpenAI API와 유사하게 REST 호출을 통해 모델 응답을 받으므로, 코드 생성 결과를 받아와 UI에 표시하면 됩니다.
Base Mini App UI/UX: Coinbase Wallet의 Mini App으로 동작하기 때문에, 사용자는 별도 웹사이트에 나갈 필요 없이 지갑 앱 내에서 바로 AI 코파일럿을 활용합니다. Mini App은 React + Next.js 기반으로 만들어지며, 코드 에디터 컴포넌트와 채팅 인터페이스를 포함합니다. 사용자가 계약 코드를 입력하거나 요청하면, 앱이 백엔드 API에 해당 요청을 보내고 AI 응답을 받아와 보여줍니다. Base 체인의 스마트 계정과 연동하여, 작성된 코드를 바로 배포(transaction)하거나, 감사지적 사항을 반영한 업데이트를 곧장 실행해볼 수도 있습니다 (사용자 서명 필요).
보안 감사 및 x402 연계: AI가 기본적인 코드 리뷰를 제공하지만, 추가로 신뢰도를 높이기 위해 서드파티 보안 분석 서비스(예: 컨트랙트 취약점 스캐너)를 통합할 수 있습니다. 이때 x402 프로토콜을 사용하여 해당 API 서비스에 자동 결제를 진행합니다. 예를 들어 사용자가 “이 코드를 포멀 검증해줘”라고 하면, Mini App 백엔드가 특정 보안 감사 API를 호출하고 비용을 요구받으면, x402로 필요한 금액을 지불하고 결과를 받아옵니다. 이를 통해 사용자는 원할 때마다 고품질의 감사 서비스를 온디맨드로 이용할 수 있으며, 결제 과정은 지갑에 연동된 USDC로 자동 처리됩니다.
기술적 구현: 백엔드는 FLock API 호출을 처리하는 Node.js 서버로 구현하고, 여기서 필요에 따라 외부 감사 서비스와 연동합니다. x402 통합을 위해 Coinbase의 예제대로 Express.js 미들웨어 (paymentMiddleware)를 설정하여 특정 엔드포인트 호출 전에 결제를 요구하도록 합니다
github.com
. 또한, 코드 생성 결과나 감사 리포트는 AgentFS를 사용해 캐시/저장할 수 있습니다. 예컨대 사용자가 여러 번에 걸쳐 코드를 개선하는 경우, AgentFS에 이전 상호작용 내용과 파일을 저장해두고 후속 프롬프트에 참고하면 더 나은 결과를 얻을 수 있습니다. 이러한 맥락 저장은 SQLite 기반의 AgentFS가 간편하게 지원하며, 향후 사용자가 작업 이력을 내려받거나 재현할 수도 있습니다.
효과: 이 아이디어는 완성도 측면에서 개발자 도구로 바로 활용될 수 있을 만큼 유용하며, Base 생태계의 스마트 컨트랙트 개발을 가속화할 것입니다. 창의성 면에서는 AI와 온체인 결제를 결합하여 “AI에게 코드를 묻고, 필요한 서비스는 자동 구매”하는 흥미로운 사용성을 제공합니다. Mini App으로 구현되어 접근성이 높고, Qwen 모델의 강력한 언어 처리로 실용성 있는 답변을 기대할 수 있습니다. 궁극적으로 Base 위에 안전하고 신속한 개발 사이클을 지원하는 도구로 자리매김할 수 있습니다.
아이디어 5: 다국어 DAO 거버넌스 AI 어드바이저
개요: Base 체인上的 DAO(탈중앙 자율 조직)들을 위한 AI 거버넌스 도우미입니다. 이 AI는 거버넌스 제안서, 토론 내용을 요약하고 찬반 의견을 분석하여, 참여자들이 더 나은 의사결정을 내리도록 도와줍니다. Alibaba Cloud의 Qwen 모델을 사용하여 영어와 한국어 등 다국어로 질의응답 및 요약이 가능하며, Base Mini App으로 구현되어 DAO 구성원 누구나 지갑 내에서 쉽게 접근할 수 있습니다. 필요한 경우 x402를 통해 외부 데이터(예: 실시간 시장 가격, 뉴스 등)를 불러오며, 이를 제안 분석에 활용합니다.
FLock 기반 NLP 분석: FLock.io API를 통해 Qwen과 같은 강력한 LLM을 활용하여 거버넌스 포럼의 긴 토론을 요약하거나 제안의 핵심 쟁점을 추출합니다. 예를 들어 “제안 A의 주요 내용과 장단점을 알려줘”라고 물으면, AI가 해당 제안서를 읽고 요약하여 찬성측 주장과 반대측 우려사항을 정리해줍니다. Qwen 모델은 추론 능력이 뛰어나 복잡한 거버넌스 논점을 논리적으로 정리할 수 있고, 한국어/영어 모두 이해하므로 다국적 DAO에도 활용 가능합니다
alibabacloud.com
. FLock API는 이러한 질문답변 작업을 대화형으로 처리하여, 사용자가 추가 질문을 하면 맥락을 이어서 답변하도록 구현합니다 (예: “그러면 재정 영향은 어떤가?” 등 추가 질의).
Base Mini App 인터페이스: Coinbase Wallet의 Mini App으로 이 도우미를 배포하여, DAO 토큰 홀더들이 지갑에서 바로 거버넌스 보조 AI를 사용할 수 있게 합니다. Mini App은 현재 진행 중인 투표 목록과 각 제안에 대한 AI 요약을 보여주고, 사용자가 클릭하면 상세 Q&A를 할 수 있는 챗봇 화면으로 전환됩니다. 사용자는 자신의 지갑 인증을 통해 DAO 멤버임을 확인받아 접근하며, AI가 제공하는 정보에 기반해 투표 또는 토론 참여를 결정하게 됩니다. Mini App은 Base 계정과 연동되어 사용자가 바로 투표(Transaction)를 실행할 수 있는 기능도 고려해볼 수 있습니다.
외부 데이터 및 x402 활용: 일부 거버넌스 제안은 온체인 데이터나 실세계 정보(예: 프로젝트 재무제표, 토큰 가격 동향)의 참고가 필요할 수 있습니다. AI가 이런 정보를 가져오기 위해, x402를 통해 해당 API나 데이터피드에 접근합니다. 예를 들어 “현재 DAO 금고의 달러 가치가 얼마야?”라는 질문에 답하기 위해 온체인 가격 오라클 API가 유료로 제공된다면, x402로 소액 결제를 수행하고 최신 환율 데이터를 받아올 수 있습니다. 이를 통해 AI는 더욱 실시간이고 정확한 정보를 거버넌스 분석에 활용합니다. (온체인 데이터의 경우 공개 API가 많지만, 프리미엄 데이터 소스도 x402로 통합 가능.)
기술적 구현 상세: 백엔드는 FLock API로 LLM 질의응답을 처리하고, DAO 포럼/스냅샷 등의 데이터를 크롤링/저장하는 모듈이 있습니다. 거버넌스 제안서는 IPFS나 포럼 API를 통해 수집하고, 중요 메타데이터(제안 ID, 링크 등)는 Base 체인에 기록하여 불변성을 보장합니다. AI 요약 결과 등을 캐싱하여 반복 질문에 빠르게 대응하기 위해 AgentFS를 사용해 볼 수 있습니다. AgentFS에 각 제안별 분석 결과를 파일로 저장해 두었다가, 동일 제안에 대한 추가 질문 시 재분석하지 않고 불러오는 식입니다.
효과: 이 AI 어드바이저는 실용성이 높아, DAO 참여자들이 정보 과부하 없이 현명한 결정을 내리는 데 기여합니다. 특히 다국어 지원으로 글로벌 DAO에 유용하며, Qwen 모델 활용으로 완성도 있는 자연어 처리가 가능함을 어필합니다. x402를 통한 데이터 결합은 창의적인 확장으로, 필요 시 AI가 경제 활동을 동반하여 더 나은 답변을 제공하는 미래형 시나리오를 보여줍니다. 궁극적으로 본 아이디어는 Base 생태계의 거버넌스 문화를 향상시키고, AI와 블록체인 협업의 새로운 가능성을 시연하는 프로젝트가 될 것입니다.
각 아이디어는 FLock.io의 API 플랫폼과 Qwen 모델을 적극 활용하면서, Base L2 인프라 및 x402 프로토콜과 결합된 참신한 아키텍처를 제시합니다. 이러한 프로젝트들은 해커톤의 요구사항을 충족할 뿐만 아니라, 분산형 AI와 온체인 애플리케이션의 시너지를 보여주어 향후 실세계에 응용될 수 있는 높은 확장성과 혁신성을 갖추고 있습니다. (각 아이디어별 구현은 5분 내외 데모 영상과 자료로 충분히 설명 가능하도록 구체화되어 있습니다.)




Sources
You said:
제 생각에는 KV Cache https://x.com/jiqizhixin/status/1985219136000299215?s=46 이걸 활용해볼 수 있을듯
ChatGPT said:
좋은 아이디어입니다! 공유해주신 KV Cache 관련 내용을 바탕으로, 이를 어떤 방향으로 해커톤 아이디어에 활용하고 싶으신지 조금만 더 구체적으로 알려주실 수 있을까요?

예를 들어:

KV Cache를 활용하여 속도를 높이고 싶은 대상은 어떤 유형의 애플리케이션인가요? (예: 실시간 채팅, 검색, 문서 요약 등)

특정한 모델 구조나 inference 단계에서 캐싱을 적용하고 싶은 부분이 있나요?

Base Mini App 또는 x402 구조 중 어느 쪽에 더 적합하다고 생각하시나요?

이 아이디어를 FLock API Platform과 어떻게 연계하고 싶으신가요?

이 정보들을 알려주시면, KV 캐시를 활용한 해커톤 아이디어를 기술적으로 정리해드릴 수 있습니다!

You said:
다음을 보고 해커톤 아이디어를 소개해주세요
# Qwen SKYST Hackathon on Base by FLock.io

### FLock.io

> [FLock.io](http://flock.io/) is the first decentralized AI training platform combining Federated Learning and blockchain to enable secure, privacy-preserving model training. It empowers communities to collaboratively build and own AI without centralizing data. Powered by the $FLOCK token, FLock drives governance, incentives, and ecosystem growth. Backed by top investors and the Ethereum Foundation, it’s reshaping AI’s future.
> 

🔗 [Website](https://www.flock.io/) | [Telegram](https://t.me/flock_io_community/80750) |  [Twitter](https://x.com/flock_io)  

## **Base**

> Base is an Ethereum Layer-2 blockchain network developed by Coinbase. It is designed to improve scalability, performance, and interoperability while reducing transaction costs and settlement time on the Ethereum network. As a decentralized platform, Base supports a wide range of dApps and smart contracts.
> 

🔗 [Website](https://www.base.org/) | [Telegram](https://t.me/daehanbase) |  [Twitter](https://x.com/daehan_base)  

### Qwen

> Qwen is a family of large language models developed by Alibaba Cloud. Built to understand and generate both Chinese and English, Qwen is designed for a wide range of applications including natural language processing, reasoning, and multimodal tasks. As an open and scalable AI foundation, Qwen powers chatbots, coding assistants, and enterprise solutions across Alibaba’s ecosystem and beyond.
> 

🔗 [Website](https://qwen.ai/home) | [Linkedin](https://www.linkedin.com/company/qwen) |  [Twitter](https://x.com/Alibaba_Qwen)  

## **🟦** Qwen SKYST Hackathon on Base 개요

Qwen SKYST Hackathon on Base는 Base의 가장 큰 AI 인프라 프로토콜인 FLock.io와 Alibaba Cloud의 Qwen이 Base와 협력하여 주최하는 AI 어플리케이션 해커톤입니다.

베이스의 다채로운 어플리케이션 생태계를 활성화하기 위해서 앱 빌더들을 지원하고 커뮤니티와 공유할 수 있는 기회입니다. 이전 Qwen SKYST Hackathon은 AI 모델을 만드는 데이터톤이었다면, 이번 해커톤은 해당 모델들을 활용하여 실제로 유저들이 활용 가능한 어플리케이션을 Base Mini App 형태로 혹은 x402를 활용한 어플리케이션/AI Agent를 만드는 해커톤입니다.

**총 진행 기간:** 2025년 11월 21일 - 11월 29일 

**해커톤 주제 1: Build an AI Application utilizing FLock.io’s API Platform as a Base Mini App**

**해커톤 주제 2: Build an AI Application utilizing FLock.io’s API Platform and x402**

## **🟦**  해커톤 소개 및 참가 방법 안내

### 🪧 ****해커톤 안내

타임라인

- 접수 기간: 11월13일 ~ 11월 22일 (선착순 100명 내외로 제한되어 조기 마감될 수 있습니다)
- API 지급: 11월 21일 ~ 11월 23일
- 킥오프: 11월 22일 오후 1시~3시
    - 진행: 온라인(상황에 따라 녹화본 배포로 변경될 수 있음)
- 온라인 해커톤 진행: 11월 22일~11월 28일 오후 6시
    - 제출 마감 기한은 11월 28일 오후 6시
    - 해커톤 플랫폼 및 결과물 제출 방법은 추후 공지 예정
- Top 8 발표 팀 선정: 11월 28일 자정
- 발표 및 최종 시상식: 11월 29일(토) 오후 2시 ~ 6시

총 상금: $15K

| 등수 | 상금 |
| --- | --- |
| 1 | $5000 |
| 2 | $3000 |
| 3 | $2000 |
| Finalist (4~8) | $1000 |

### 📝 해커톤 참가 신청서

[Qwen SKYST Hackathon on Base 신청서](https://forms.gle/nB6cvYkyJknujBof6)

한 팀은 총 1~3명으로 구성됩니다

### 💡 해커톤 주제

✅ 필수 조건

1. FLock.io의 [API Platform](https://docs.flock.io/flock-products/api-platform/getting-started)의 API를 이용 (OpenAI API 사용하는것과 유사)
2. 다음중 두가지 중에서 하나를 충족
    1. [Base Mini App](https://docs.base.org/mini-apps/quickstart/create-new-miniapp) 만들기 
    2. [x402](https://www.coinbase.com/developer-platform/products/x402) 활용한 어플리케이션 혹은 AI Agent 만들기

킥오프에 해당 API 등을 사용하기 위한 간단한 Vibe coding session이 진행될 예정입니다

참고 예시: Vibe Master by [FLock.io](http://FLock.io)

- [데모 영상](https://x.com/0x7SUN/status/1984020009992253749?s=20)
- [웹사이트](https://vibe.flock.io/login)

✔️ 평가 항목

- 완성도 (30%)
- FLock API 활용도 (30%)
- 창의성 (20%)
- 실용성 (20%)

**제출 자료:**

1. 5분 이내의 프로젝트 설명 및 데모 (영상)
2. 프로젝트 소개 슬라이드, 팀 구성원 소개 (PDF)
3. 프로젝트 설명 (추후 양식 공개 예정)

## **🟦**  행사 정보

---

해커톤 데모데이 발표 및 시상식 일정: 2025년 11월 29일(토) 오후 2시 ~ 6시

장소: 드림플러스 강남 지하 1층

주최: FLock.io, Base, Alibaba Cloud

참가 대상: Base 및 AI 어플리케이션 개발에 관심 있는 학생, 개발자, 컨텐츠 제작자 등

### 데모데이 타임라인

14:00~14:30 Registration

14:30~14:45 Closing remarks by [FLock.io](http://FLock.io) (Jiahao Sun, CEO)

14:45~15:00 Closing remarks by Base (David, Head of East Asia)

15:00~15:15 Closing remarks by Alibaba Cloud (Stone, Head of Business Development)

15:15~16:30 Top 8 Team 데모 발표

16:30~17:00 Break Time 및 Top Team 최종 심사

17:00~17:15 우승자 발표 및 시상식

17:15~18:00 Networking


----------

예를 들어 https://github.com/tursodatabase/agentfs 이런걸 활용한다거나 

제 생각에는 KV Cache https://x.com/jiqizhixin/status/1985219136000299215?s=46 이걸 활용해볼 수 있을듯

다양한 아이디어를 아주 기술적으로 자세하게 만들어보세요
ChatGPT said:
좋습니다. FLock.io API, Base Mini App 또는 x402, 그리고 agentfs 및 KV Cache까지 포함하는 다양한 기술적 요소를 활용하여 매우 구체적이고 실현 가능한 해커톤 아이디어들을 설계해드리겠습니다. 아이디어는 Qwen 모델 기반 AI 응용의 실용성과 창의성을 중심으로 구성할 예정입니다.

완성되는 대로 알려드릴게요. 편하게 기다려주세요!

Research completed in 5m · 13 sources · 52 searches
Qwen SKYST 해커톤 프로젝트 아이디어
Qwen SKYST 해커톤 on Base는 FLock.io의 분산형 AI 플랫폼과 Alibaba Cloud의 Qwen LLM을 활용해 Base 네트워크에서 혁신적인 AI 어플리케이션을 개발하는 행사입니다. 참가자들은 FLock의 OpenAI 호환 API를 통해 Qwen 모델을 사용하고, Coinbase Base 환경에서 Mini App 형태로 배포하거나 x402 프로토콜을 활용한 애플리케이션을 만들어야 합니다. 아래에는 해커톤 주제에 부합하면서도 창의적이고 기술적으로 도전적인 몇 가지 프로젝트 아이디어를 소개합니다.
아이디어 1: C2C 다중 LLM 협업 에이전트
컨셉: 두 개 이상의 **대형 언어 모델(LLM)**이 서로 텍스트 없이 직접 상호작용하여 더 나은 해답을 도출하는 Cache-to-Cache (C2C) 협업 에이전트입니다. 예를 들어 Qwen 모델 두 개를 역할별로 (하나는 문제 해석, 하나는 솔루션 생성 등) 구동하고, KV 캐시를 교환함으로써 중간 추론 과정을 공유합니다. 이를 통해 모델들은 서로의 숨은 상태(hidden state)를 활용하여 정확도와 응답 속도를 향상시킵니다
huggingface.co
. 사용자는 Base Mini App을 통해 질의를 입력하면, 백엔드에서 다중 LLM이 캐시 기반 대화를 거쳐 최적의 답변을 산출합니다.
기술 포인트: C2C 기법은 모델 간 KV-캐시를 프로젝션 및 융합하여 텍스트 생성 과정을 생략합니다
huggingface.co
. 연구에 따르면 이 접근은 개별 모델 대비 정확도 8.5–10.5% 개선, 텍스트 채팅 대비 3–5% 성능 향상 및 2배 응답 지연 감소를 보여줍니다
huggingface.co
. 해커톤 프로젝트로 이를 구현하려면 오픈소스 Qwen 모델 인스턴스를 두 개 구동하고, Attention KV 캐시를 중간에 추출/주입하는 엔지니어링이 필요합니다.
구현 방식: FLock.io의 API 플랫폼을 이용해 Qwen LLM을 호출하되, 첫 번째 모델의 추론 단계에서 KV 캐시를 얻어와 두 번째 모델 입력에 결합합니다. 예를 들어 하나의 에이전트가 사용자 질문을 논리적으로 분석하고, 다른 에이전트가 분석 결과를 이어 받아 답변을 완성하도록 모델 파이프라인을 구성합니다. 이러한 C2C 에이전트는 일반 대화형 LLM 대비 추론 과정을 노출하지 않고도 협업하여 높은 품질의 답변을 빠르게 도출할 수 있습니다
huggingface.co
. Base Mini App UI를 통해 사용자 질문을 받고 결과를 출력함으로써, 다중 LLM 협업의 강점을 보여주는 혁신적 사례가 될 것입니다.
아이디어 2: AgentFS 기반 지속 학습 비서
컨셉: 대화와 작업 이력을 지속적으로 학습하며 스스로 진화하는 개인 AI 비서를 개발합니다. AgentFS를 활용하여 에이전트의 모든 상태와 파일을 하나의 SQLite 데이터베이스에 저장함으로써, 사용자별 장기 메모리와 행동 이력 추적을 구현합니다
turso.tech
. 이 비서는 대화 내용을 기억하고 사용자의 선호도를 축적하여, 시간이 지날수록 더 개인화되고 똑똑해집니다. FLock의 Qwen 모델을 백엔드로 사용하고, Coinbase Base 지갑의 Mini App으로 프론트엔드를 제공하여 온체인 신원과 연동된 퍼스널 AI를 만드는 것이 목표입니다.
기술 포인트: AgentFS는 Turso의 SQLite 기반 에이전트 파일시스템으로, 에이전트의 파일, 키-값 상태, 툴 사용 내역 등 모든 데이터를 하나의 DB 파일에 기록합니다
turso.tech
. 이를 통해 완전한 가시성과 재현성을 갖춘 에이전트를 만들 수 있습니다. 예를 들어, 비서 에이전트가 매번 한 대화의 요점을 /memory/notes.txt 등에 파일로 저장하거나, kv 스토어에 사용자 설정을 기록해 둔다면, 이후 세션에서 즉시 불러와 참고할 수 있습니다. 모든 변화는 SQLite에 축적되므로, 필요 시 SQL 쿼리로 과거 기록을 분석하거나 버그를 추적할 수도 있습니다
turso.tech
.
구현 방식: Base Mini App으로 간단한 채팅 인터페이스를 만들고, 사용자가 지갑으로 로그인하면 개인별 AgentFS DB를 초기화합니다. Qwen LLM과의 대화는 FLock API로 처리하되, 프롬프트에 매번 AgentFS에 저장된 과거 대화 요약이나 사용자 프로필 데이터를 삽입하여 컨텍스트 지속성을 확보합니다. 예컨대 “최근에 사용자가 질문한 내용 요약”이나 “선호 답변 스타일” 등을 DB에서 꺼내 프롬프트에 반영합니다. 또한 중요한 대화 이벤트마다 AgentFS에 로그를 남겨 행동 추적을 합니다. 이러한 비서는 대화가 쌓일수록 똑똑해지며, 모든 데이터가 사용자의 로컬 DB에 있으므로 프라이버시도 지킬 수 있습니다 (원하면 DB 해시를 Base 체인에 기록해 무결성 검증 가능). 결과적으로, 지속 학습과 투명한 메모리를 갖춘 AI 비서를 선보일 수 있을 것입니다.
아이디어 3: x402 자율 결제 에이전트
컨셉: x402 프로토콜을 활용해 자동으로 결제까지 수행하는 자율 에이전트를 구축합니다. 이 에이전트는 필요한 정보나 서비스를 얻기 위해 인간처럼 신용카드를 쓰는 대신, 스테이블코인으로 HTTP 요청 중 결제를 합니다
coinbase.com
coinbase.com
. 예를 들어 사용자가 “최신 해외 주식 시장 뉴스를 요약해줘”라고 요청하면, 에이전트는 유료 API의 최신 데이터 엔드포인트를 호출하고, 즉석에서 x402로 소액결제를 처리하여 데이터를 획득한 뒤 Qwen LLM으로 요약해 제공합니다. 사람의 개입 없이도 필요한 리소스를 스스로 구매하여 임무를 수행하는 진정한 경제적 자율성을 보여줍니다
coinbase.com
.
기술 포인트: Coinbase의 x402는 HTTP 402 코드를 활용한 네이티브 웹 결제 표준으로, **AI 에이전트가 자동으로 안정적인 코인(예: USDC)**을 주고받을 수 있게 합니다
coinbase.com
. 이로써 API 호출당 마이크로페이먼트 과금이나, 프리미엄 기능 온디맨드 구매 등이 수월해집니다
coinbase.com
coinbase.com
. 실제 활용 시나리오로 **“에이전트가 필요한 데이터 소스를 요청하고 건당 비용을 지불”**하거나
coinbase.com
, **“추가 연산 자원을 실시간 임대”**하는 것까지 가능해집니다
coinbase.com
. x402를 통해 인증, 정산, 결제가 한 번에 이루어지므로, 에이전트는 마치 사람이 지갑으로 결제하듯 웹상의 서비스를 프로그래밍적으로 구매할 수 있습니다
coinbase.com
.
구현 방식: 우선 FLock의 API로 구동되는 Qwen LLM 에이전트를 설계하되, 외부 데이터가 필요할 때 HTTP 402 요구를 처리하는 로직을 추가합니다. 예컨대 뉴스 요약 에이전트의 경우, 뉴스 API가 “402 Payment Required”를 응답하면, 에이전트는 미리 연결된 사용자의 Base 지갑(또는 사전에 충전된 에이전트 지갑)을 통해 자동으로 USDC 결제 트랜잭션을 발생시킵니다. 결제가 완료되면 API로부터 데이터를 받아와 LLM이 처리합니다. Base Mini App으로 사용자에게는 대화 UI와 함께 “$0.05 결제하여 최신 뉴스를 구매했습니다” 같은 피드백을 보여주어 투명성을 줍니다. 이 프로젝트는 x402의 자율 에이전트 결제 사례를 시연하여, AI 에이전트가 스스로 가치 교환을 수행하는 Web3 시대의 활용 예를 제시합니다
coinbase.com
. (추가로, 여러 에이전트가 머신-투-머신으로 서로 서비스와 데이터를 x402로 거래하게 확장하면 에이전트 경제도 구현해볼 수 있습니다.)
아이디어 4: 스마트 컨트랙트 AI 감사 미니앱
컨셉: 블록체인 스마트 컨트랙트 코드를 AI가 자동으로 검토 및 감사해주는 도구입니다. 사용자는 Base 네트워크의 특정 컨트랙트 주소를 Mini App에 입력하면, 백엔드에서 해당 컨트랙트의 소스코드를 불러와 Qwen 모델로 보안 취약점, 버그, 최적화 포인트 등을 분석합니다. Qwen은 대형 코드베이스도 한 번에 이해할 수 있을 만큼 맥락 처리 능력이 뛰어나므로
aimagazine.com
, 단일 컨트랙트뿐 아니라 여러 연관 컨트랙트까지 함께 살펴볼 수 있습니다. 결과물은 사람이 읽기 쉬운 리포트 형태로 제공되어 개발자나 보안 감사자가 활용할 수 있게 합니다.
기술 포인트: Alibaba Cloud의 Qwen LLM 중 Qwen-코더 모델은 최대 수십만 토큰에 이르는 코드도 한 번에 처리할 수 있고, 버그 수정 및 이해 능력이 탁월한 것으로 알려져 있습니다
aimagazine.com
aimagazine.com
. 예컨대 Qwen3-Coder는 최대 256,000 토큰의 코드베이스를 자연어로 분석하고 문제를 식별할 수 있어, 복잡한 스마트 컨트랙트도 한 세션에 감사 가능함을 보여줍니다
aimagazine.com
. 또한 Mixture-of-Experts 구조로 전문적인 코드 작업에 최적화되어 있어, OpenAI GPT-4 수준의 코드 이해력으로 경쟁한다고 보고되었습니다
aimagazine.com
. 이러한 모델을 사용하면 Solidity 코드의 알려진 취약점 패턴을 찾아내거나, 함수 단위로 가스 최적화 제안, 의심스러운 논리 경고 등을 생성할 수 있습니다.
구현 방식: Base의 온체인 데이터 접근을 위해, 사용자가 입력한 컨트랙트 주소의 소스코드를 EtherScan API나 Base 노드 RPC로 가져옵니다. 그 코드 텍스트를 프롬프트로 구성하여 FLock API의 Qwen 모델에 전달합니다 (토큰 길이가 긴 경우 Qwen의 장문 입력 기능 활용). 모델 프롬프트에는 “이 Solidity 코드를 감시해 취약점, 백도어 가능성, 비효율적인 부분을 찾아 상세히 설명하라”와 같은 지침을 줍니다. Qwen이 출력한 감사 결과를 Mini App UI에 마크다운 리포트로 보여주거나, 중요 이슈를 리스트 형태로 표시합니다. 필요하면 AgentFS를 접목해 이전 감사 기록이나 결과를 DB에 저장하고, 나중에 버전 비교나 추적도 가능하게 할 수 있습니다. 이 프로젝트는 블록체인 개발과 AI 코드 분석을 접목한 것으로, Base 생태계 개발자들에게 유용한 툴이 될 뿐 아니라 해커톤 주최 측에서 요구하는 Base Mini App 구현과 FLock(Qwen) AI 활용 요건도 만족합니다.
각 아이디어는 FLock.io의 AI 모델 API를 중심에 두고, Base 인프라를 활용하거나 x402 프로토콜을 접목하여 해커톤의 요구사항을 충족합니다. 참가자는 위 아이디어들을 참고하여 자신만의 창의적인 변주를 시도해볼 수 있으며, 기술적으로 깊이 있게 구현함으로써 높은 완성도, 창의성, 실용성을 어필할 수 있을 것입니다. 특히 KV 캐시 공유나 AgentFS 같은 최신 개념을 도입하면 FLock + Qwen 조합의 강점을 극대화하고 경쟁에서 두각을 나타낼 수 있습니다. 이 해커톤을 통해 AI와 블록체인의 최첨단 결합을 선보이는 멋진 프로젝트가 나오길 기대합니다.





Sources
You said:
이 중에서 가장 수상 가능성이 높은 아이디어 2개만 추출하고 그에 대해 Develop 하라
ChatGPT said:
두 아이디어 중 수상 가능성이 가장 높은 2개를 뽑고, 해커톤 기준(완성도·FLock 활용도·창의성·실용성)을 만족하도록 실제 구현 관점에서 빡세게 개발 계획까지 깔아볼게요. 제가 고른 2개는:
(Topic 1용) Base Mini App + FLock + AgentFS + KV 캐시
→ “Base Memory Agent: 지갑에 붙는 지속 학습 AI 코파일럿”
(Topic 2용) x402 + FLock + AgentFS + KV 캐시
→ “x402 Research Agent: 스스로 결제하고 데이터를 사오는 자율 리서치 에이전트”
1. Base Memory Agent
— Base Mini App + FLock + AgentFS + KV Cache 기반 지속 학습 코파일럿
1-1. 한 줄 피치 & 왜 유리한지
“지갑으로 로그인하면, 나만의 기억을 갖는 AI 코파일럿이 Base Mini App 안에 붙어있는 형태”
완성도 (30%)
MiniKit + OnchainKit 템플릿으로 UI/지갑/배포를 빠르게 가져가고, AgentFS로 메모리/로그를 구조화해서 꽤 안정적인 MVP까지 가능.
Base Documentation
+1
FLock API 활용도 (30%)
OpenAI 호환 API라 기존 OpenAI 클라이언트 코드를 거의 그대로 쓰되 baseURL만 FLock으로 변경해서 여러 기능(대화, 요약, RAG)을 모두 FLock으로 처리.
Flock
+2
Flock
+2
창의성 (20%)
최신 AgentFS(“에이전트용 파일 시스템”)를 써서 AI의 파일/상태/툴 사용을 전부 SQLite에 기록하는 구조 + KV 캐시 최적화까지 언급하면 “요즘 스택 잘 아는 팀”으로 보이기 딱 좋음.
GitHub
+1
실용성 (20%)
“나만의 기억을 가진 AI 비서”는 DevRel, 크리에이터, 개인 지식 정리 등 직관적인 사용 사례가 많아서 데모 설득력이 큼.
1-2. 주요 사용자 경험 (UX 플로우)
지갑 로그인 & 프로필 생성
사용자가 Base App/Farcaster 클라이언트에서 Mini App 실행 → MiniKit / OnchainKit으로 지갑 연결.
Base Documentation
+1
첫 진입 시 “닉네임 / 관심 분야” 입력 → AgentFS 안의 /profile.json에 저장.
대화 & 태스크 실행
사용자가 “이 해커톤 공지 요약해줘”, “내 GitHub README 개선해줘” 같은 요청.
백엔드가 3가지 레이어로 동작:
Short-term context: 이번 세션 대화 내역 (KV 캐시 + 최근 n turns)
Long-term memory: AgentFS에 저장된 요약/노트/파일들
User profile: 선호 스타일, 이전 작업 기록
FLock(Qwen)에게 프롬프트:
system: “You are a long-term personal AI assistant for wallet 0xabc…”
context: long-term memory에서 가져온 노트 + 최근 대화
user: 현재 질문
결과 저장 & 학습
응답 후, 중요도 높은 내용(새로운 fact, 사용자의 취향, todo 등)을 AgentFS의:
/notes/YYYY/MM/DD-*.md
/tasks/todo.json
/kv/preferences.sqlite
에 업데이트.
다음 방문 시
같은 지갑으로 들어오면 이전 메모리 자동 로딩:
“지난 번에 Base 해커톤 준비하신 분 맞죠? 지난 대화에서 이런 얘기 나왔는데, 계속 이어서 할까요?” 같은 자연스러운 follow-up.
1-3. 시스템 아키텍처
구성 요소
Frontend (Mini App)
Next.js + MiniKit + OnchainKit
지갑 연결, 채팅 UI, 히스토리/노트 뷰어
Backend (API 서버)
Node.js/Express 또는 Fastify
FLock API 프록시 레이어
AgentFS 연동 (TS SDK 혹은 REST wrapper)
KV 캐시 및 세션 관리 (Redis / in-memory + optional local inferencer)
Storage
Turso 또는 SQLite (AgentFS가 내부적으로 SQLite schema 사용)
Turso
Onchain
Base chain:
(옵션) 사용자별 “메모리 root hash”를 저장하는 간단한 컨트랙트 (검증용)
데이터 플로우
Mini App → Backend
{ walletAddress, message, sessionId }
Backend
AgentFS에서 walletAddress 기준으로:
/memory/summary.md, /profile.json, /tasks/*.json 읽기
KV 캐시에서 sessionId별 최근 context lookup
FLock API 호출 (OpenAI 호환)
POST https://api.flock.io/v1/chat/completions 
Flock
+1
응답 처리 후
AgentFS에 새 로그/노트 append
KV 캐시 업데이트
Mini App에 스트리밍 응답
1-4. FLock API 설계 (프롬프트 & 엔드포인트)
엔드포인트
POST /v1/chat/completions (OpenAI chat과 동일 인터페이스)
Flock
+1
예시 코드 (의사 코드)
const client = new OpenAI({
  baseURL: "https://api.flock.io/v1",
  apiKey: process.env.FLOCK_API_KEY,
});

const messages = [
  {
    role: "system",
    content: `
You are a long-term personal AI agent for wallet ${walletAddress}.
You have access to the user's profile and long-term notes.
Always keep answers concise, and update your memory notes when new stable facts appear.
`,
  },
  { role: "user", content: userMessage },
  { role: "assistant", content: longTermSummary }, // few-shot 형태로 주입 가능
];

const completion = await client.chat.completions.create({
  model: "qwen-32b-instruct", // 실제 FLock 제공 모델 이름으로 변경
  messages,
  stream: true,
});
FLock 활용 포인트
대화형 Chat + 요약 기능
긴 대화/문서 → “이걸 장기 기억용 bullet point로 정리해줘” 같은 meta 프롬프트로 요약 저장
(옵션) Embeddings
FLock가 OpenAI-style embeddings도 지원한다면, AgentFS 위에 작은 벡터 인덱스 레이어를 얹어 RAG 형태로 long-term memory 검색 (코드/문서 정리용).
Flock
+1
1-5. AgentFS 사용 설계
AgentFS는 에이전트용 파일시스템으로, 내부적으로 SQLite schema로 파일·디렉토리·상태를 저장하는 구조입니다.
GitHub
+1
 디렉토리 구조 예시
/users/{wallet}/
profile.json — 이름, 언어, 톤(공손/캐주얼), 관심사
memory/summary.md — 전체 기억 요약
memory/daily/2025-11-22.md — 날짜별 로그/노트
tasks/todo.json — 할 일 목록
sessions/{sessionId}.json — 세션별 메타데이터 (시작시간, 태그 등)
패턴
대화 후 메모리 업데이트
FLock에 “이번 대화 핵심 정리 + 장기기억에 추가할 사실” 요청
결과를 memory/daily/*.md에 append
다음 대화 시작 시
최근 n일 memory/daily 파일을 summarization → memory/summary.md 업데이트
summary.md 일부를 system prompt에 넣음
분석/리플레이 가능성
SQLite라서 해커톤 데모 때 SELECT * FROM events WHERE user = ? 같은 SQL을 보여주며
“에이전트가 어떤 의사결정을 내렸는지 완전히 추적 가능” 어필 가능
1-6. KV Cache 활용 설계
여기서의 “KV Cache”는 두 레벨로 활용할 수 있습니다.
실용적인 레벨 (해커톤 MVP에 바로 적용)
FLock API는 내부적으로 KV 캐시를 활용해 토큰 단위 추론을 최적화하겠지만, 우리는 API 레벨이므로 직접 만지긴 어려움.
대신, 세션 컨텍스트 관리를 최적화:
최근 n 턴만 전체 문장을 포함하고, 그 이전은 FLock에게 요약시켜 “압축 컨텍스트”로 교체 → 실질적으로 KV 캐시 부담을 줄이는 효과.
Redis/in-memory 캐시에 sessionId → {recentMessages, compressedHistory}를 저장해 재사용.
실험적 레벨 (KV Cache / C2C 언급용 + 점수용)
사용자가 제안한 C2C/전문 KV-cache 연구는, 실제로는 오픈소스 Qwen 로컬 인스턴스에 적용하면 좋음:
C2C 논문에서 말하듯, KV-cache를 모델 간 직접 전달/융합하면 성능·지연시간이 좋아짐.
arXiv
+2
arXiv
+2
구조:
“Planner LLM”(로컬 Qwen)과 “Writer LLM”(FLock Qwen)을 분리
Planner 쪽에서 나온 KV-cache를 로컬에서 활용해 multi-step reasoning을 빠르게 하고,
최종 natural language 응답은 FLock API로 생성 → 해커톤 요건(FLock API 필수)을 지키면서도 “KV cache aware design”을 넣을 수 있음.
데모/슬라이드에서:
“우리는 최신 C2C 연구를 참고해 KV Cache를 고려한 아키텍처를 설계했고, 장기적으로는 KV 기반 cross-agent 협업을 구현할 계획이다”라고 어필 가능.
1-7. 구현 스택 정리
Frontend: Next.js / React, MiniKit, OnchainKit
Base Documentation
+1
Backend: Node.js + Express/Fastify
AI: FLock API Platform (OpenAI SDK 호환, Qwen 계열 모델 활용)
Flock
+1
Agent FS: AgentFS + Turso/SQLite
GitHub
+1
Cache: Redis(in-memory)
Auth: Base account(지갑 주소) = user id
1-8. 해커톤 7~8일 일정 기준 구현 플랜 (대략)
Day 1–2
Mini App 템플릿 띄우기 (Vercel + MiniKit quickstart)
FLock API 연결, 기본 챗봇까지
Day 3
AgentFS 연동, walletAddress 기반 디렉토리 분리
메모리 파일 읽고/쓰는 최소 플로우
Day 4
“장기기억 요약” 파이프라인 (FLock 요약 + AgentFS 저장)
세션별 KV 컨텍스트 캐싱 로직
Day 5
UI: 노트 뷰/편집, 최근 대화 기록, “메모리 리셋” 기능
Day 6
에러 핸들링, 로깅, 지갑 연동 UX 정리
Day 7
데모 스크립트, 5분 영상 촬영, 슬라이드 최종 정리
2. x402 Research Agent
— x402 + FLock + AgentFS + KV Cache 기반 자율 결제 리서치 에이전트
이번에는 해커톤 **주제 2 (FLock + x402)**를 제대로 치는 아이디어입니다.
2-1. 한 줄 피치 & 강점
“최신 온체인/오프체인 데이터를 스스로 유료 API에서 사오고, FLock(Qwen)으로 정리해서 보고서를 써주는 AI 리서치 에이전트”
사용자는 “이 토큰/프로토콜에 대해 리서치 리포트 작성” 정도만 지시
에이전트가:
어떤 API가 필요한지 계획 (DeFi, 뉴스, 온체인 데이터 등)
각 API 요청 → 402 응답 수신
x402로 자동 결제 후 데이터 수신
x402.org
+3
Coinbase Developer Docs
+3
GitHub
+3
FLock(Qwen)으로 종합 분석/요약
AI 에이전트가 스스로 돈을 쓰는 구조라 x402의 “AI-native payment” 비전을 그대로 보여주는 데모라서 창의성 점수도 높게 먹을 수 있음.
Coinbase
+2
fintechwrapup.com
+2
2-2. 주요 시나리오
리서치 요청
사용자가 Web UI 또는 Mini App에서
“UNI 토큰의 지난 6개월 온체인 활동, 가격, 주요 뉴스 기반 리서치 리포트 작성해줘 (요약 1장 + 디테일 3장)”
동시에 “최대 예산 3 USDC” 설정.
플래닝 (FLock LLM)
FLock Qwen에게 “필요한 데이터 소스, 순서, 예상 비용”을 먼저 짜게 함.
예:
DEX 가격/볼륨 API
온체인 홀더 분포 API
뉴스/트위터 요약 API
데이터 수집 + x402 결제
각 데이터 소스에 HTTP 요청:
만약 해당 API가 x402 기반 pay-per-call이라면 402 Payment Required 응답.
x402.org
+4
Coinbase Developer Docs
+4
GitHub
+4
에이전트가 x402 클라이언트로 즉시 USDC 전송.
예산(3 USDC) 내에서만 호출 허용.
분석 & 리포트 생성
수집된 JSON/CSV/텍스트들을 FLock Qwen에 넘겨:
1장 요약
세부 분석 3장
“리스크/기회/결론” 섹션 포함
결과를 마크다운 혹은 PDF로 변환.
결과 & 사용 내역 표시
사용자 화면:
리포트 내용
“이 리포트를 위해 사용한 API 목록 / 각 호출 비용 / 총 소모 USDC”
이 모든 작업 로그를 AgentFS에 저장 → 투명성과 재현성 확보.
2-3. 아키텍처
구성 요소
Frontend
선택 1: 일반 Web + 지갑 연결(wagmi)
선택 2: Farcaster Mini App + x402 miniapp 템플릿 (공식 예제 활용)
Coinbase Developer Docs
Backend
Node.js/Express
x402 클라이언트 (coinbase/x402 repo 참고)
GitHub
+1
FLock API 클라이언트
AgentFS 연동 (리서치 로그 저장)
KV 캐시 (중간 추론 결과/요약 캐시)
Onchain
Base chain 상의 유저 지갑 또는 “Research Agent 지갑”
(옵션) 리포트 해시를 Base에 기록 → 위변조 방지
데이터/컨트롤 플로우
User → Backend
요청: { topic, budgetUSDC, depthLevel }
Backend → FLock
“이 주제에 대해 조사 계획 세워줘. 필요한 데이터 소스와 호출 순서, 각 호출 목적을 JSON 형태로 내놔.”
Backend → External APIs
각 플랜에 따라 HTTP GET/POST
402 나오면 x402 결제 플로우 수행.
Backend → FLock
수집 데이터 + 최종 리포트 생성 프롬프트
Backend → AgentFS
/reports/{id}.md, /payments/{id}.json, /sources/{id}.json 저장
Frontend
리포트 및 호출 영수증 UI 표시
2-4. x402 통합 상세
x402는 HTTP 402 Payment Required 코드를 이용해 **“요청 → 결제 → 자원 제공”**을 한 번의 플로우로 처리합니다.
x402.org
+4
Coinbase Developer Docs
+4
GitHub
+4
 기본 시퀀스
클라이언트(우리 백엔드)가 유료 API를 호출
서버가 402 Payment Required + 결제 정보(x402 메타데이터) 응답
우리 백엔드가 x402 프로토콜에 맞춰 USDC 결제 트랜잭션 생성/송신
결제 성공 후, 서버가 실제 데이터 반환
해커톤에서의 구현 전략
가장 빠른 접근:
Coinbase의 x402 GitHub repo의 fullstack miniapp 예제를 참고해서 우리 백엔드에 붙이기.
Coinbase Developer Docs
+1
우리 서비스 입장에서는 x402를:
paywalledFetch(url, options, maxPrice) 같은 헬퍼 함수로 감싸서:
일반 fetch
402 수신 시 x402 결제 실행
성공 시 데이터 반환
2-5. FLock API 활용 설계
(1) 플래닝 LLM 호출
const planPrompt = `
You are a research planner agent.
User query: "${topic}"
Budget: ${budgetUSDC} USDC.

1. List 3-6 external data sources (APIs, websites) you would call.
2. For each, specify:
  - name
  - url (placeholder if unknown)
  - type: [onchain, defi, news, social]
  - max_calls
  - importance (1-5)
Return strict JSON array.
`;

const plan = await flock.chat.completions.create({
  model: "qwen-32b-instruct",
  messages: [{ role: "user", content: planPrompt }],
});
(2) 리포트 작성 LLM 호출
수집한 데이터를 text로 pre-process 후:
const reportPrompt = `
You are a crypto research analyst.

User query: "${topic}"

Below are JSON blobs of data collected from multiple APIs.
Summarize them into:
1. One-page executive summary
2. Three sections: [On-chain metrics, Market activity, Narrative & News]
3. Risks and Opportunities
4. Final recommendation (bullish / neutral / bearish) with justification.

Data:
${combinedDataText}
`;

const report = await flock.chat.completions.create({
  model: "qwen-32b-instruct",
  messages: [{ role: "user", content: reportPrompt }],
});
FLock API는 OpenAI 호환이라, 기존 openai SDK를 그대로 쓰고 baseURL만 https://api.flock.io/v1로 바꾸면 됩니다.
Flock
+2
Flock
+2
2-6. AgentFS + KV Cache 설계
AgentFS
/research/{wallet}/{requestId}/
plan.json — LLM이 만든 조사 플랜
payments.json — 각 x402 결제 기록 (amount, tx hash, target API)
raw/*.json — 원본 응답들
report.md — 최종 리포트
meta.json — budget, status, 실행 시간
데모에서:
“이 요청으로 어떤 API를 얼마나 호출했고, 어디에 얼마를 썼는지”를 AgentFS에서 바로 꺼내서 보여줄 수 있음 → 투명성 + 감사 가능성 강조.
KV Cache
리서치 과정은 multi-step이라, 중간중간:
“지금까지 수집된 데이터 요약”을 LLM에 여러 번 물어볼 수 있음.
동일 topic 반복 시:
이전 리포트와 중간 요약을 KV 캐시에 올려두고,
새 요청에서 “변화만 분석”하도록 설계 → 토큰 절약 & 응답 속도 향상.
확장 아이디어(슬라이드용 어필):
C2C 논문처럼 LLM들끼리 KV를 공유하면 text로 중간 결과를 주고받지 않아도 되어 추론 속도 2배, 정확도 8~10% 향상을 기대할 수 있다는 연구 결과가 있음.
arXiv
+3
arXiv
+3
arXiv
+3
해커톤 버전에서는 완전한 C2C 구현은 어렵지만,
“플래너 LLM”과 “리포트 LLM” 사이의 컨텍스트를 최소화/요약하는 방식으로 KV-aware 설계 철학을 반영했다고 설명 가능.
2-7. 구현 타임라인 (예시)
Day 1
기본 웹 UI + FLock 챗봇 붙이기
Day 2
“리서치 플랜 생성” LLM 호출 완성
Day 3
가짜 유료 API(테스트 서버) 만들어 x402 402→결제→데이터 플로우 테스트
Day 4
여러 API 응답을 합쳐서 리포트 생성 파이프라인 완성
Day 5
AgentFS에 리서치 결과/결제 로그 저장, 결과 조회 UI
Day 6
UX 다듬기 + 에러 핸들링 + “예산 초과 방지” 로직
Day 7
데모 스크립트, 녹화, 슬라이드
마무리: 어떤 방향으로 포지셔닝할지
아이디어 1 (Base Memory Agent)
“Base 생태계 유저들을 위한 온체인 ID 연동 퍼스널 AI 코파일럿”
Mini App + FLock + AgentFS + (KV-aware 컨텍스트 관리) 를 강조
아이디어 2 (x402 Research Agent)
“AI 에이전트가 x402로 스스로 결제하며 Web/API 리서치를 수행하는 미래형 에이전트”
FLock으로 reasoning, x402로 결제, AgentFS로 완전한 기록/감사를 제공하는 풀스택 Web3 AI 데모
둘 다 우승 가능성이 충분히 있는 구조라,
팀이 프론트/지갑에 강하면 → 1번 중심,
백엔드/인프라, 프로토콜에 강하면 → 2번 중심
으로 가고, 남는 여력이 있으면 둘을 살짝 엮어서 “Memory Agent가 x402 Research 기능을 플러그인처럼 호출”하는 식으로 확장해도 좋습니다.
원하시면 이 중 하나를 골라서 실제 레포 구조(폴더 구조, API spec, DB 스키마)까지 더 쪼개 드릴게요.
You said:
너무 재미가 없는데요 더 기술적으로 "신박한 것" 아이디어를 2갠 ㅐ보세요 그러면서 구현하기도 쉽고 또 들었을 때 딱 수상할만한거
ChatGPT said:
그럼 진짜 “듣자마자 와 이건 상 줄 만하다” 느낌 나는 걸로 새로 2개 뽑아볼게요.
컨셉은:
완전 신박하고
구현은 해커톤 기간 내에 충분히 가능하고
FLock / Base / x402 / AgentFS / KV Cache 스토리가 자연스럽게 들어가는 것
으로 잡았습니다.
아이디어 1
🧙‍♂️ AgentFS Dungeon — LLM이 게임 마스터인 온체인 로그라이크
Base Mini App 안에서 돌아가는 텍스트 로그라이크 게임
게임 월드는 전부 AgentFS(파일 시스템) 로 저장
Qwen(FLock API)이 실시간으로 던전/이벤트/스토리 생성
유저의 진행 상황, 인벤토리, 월드 상태는 디렉토리와 파일로 표현
클리어/엔딩 시점에 Base NFT로 “던전 클리어 기록” 민팅
KV Cache 느낌으로 “월드 프리픽스”를 캐시해서 빠른 응답
1-1. 사용자 입장에서
Base Mini App 실행 → 지갑 연결
“새 던전 시작하기” 클릭
LLM이 프롬프트 기반으로 던전 설정 생성:
난이도, 세계관(사이버펑크, 판타지, SF…), 플레이 스타일 등
유저는 채팅으로만 게임 진행:
“왼쪽 문 연다”, “상자 연다”, “도주한다”, “스킬 사용”
Qwen이 게임 마스터(던전 마스터) 역할
상황 묘사 + 결과 + 선택지 제안
전투/상호작용 결과를 AgentFS 상의 파일로 업데이트
던전 클리어 / 사망 / 특정 엔딩 도달 시:
해당 세션을 온체인 NFT로 민팅 (텍스트 요약 + 메타데이터)
나중에 Mini App에서 내 “던전 기록”들 리스트로 보여줌
“아니 해커톤에서 게임이야?” 할 수 있는데, 이건 단순 게임이 아니라
“AI Agent + AgentFS + Base를 이용한 LLM-native stateful world” 데모라서 기술적으로 꽤 신박합니다.
1-2. 아키텍처
프론트 (Base Mini App)
Next.js + Base Mini App 템플릿
컴포넌트:
Chat UI (user ↔ Dungeon Master)
Dungeon log viewer (scroll)
Inventory / status panel (AgentFS에서 읽어와 렌더링)
“던전 시작 / 재개 / 엔딩 요약 NFT 보기” 버튼
백엔드
Node.js / Fastify
모듈:
AgentFS Adapter
/world/{wallet}/{runId}/ 디렉토리 관리
Game Engine
유저 입력 → FLock(Qwen) 프롬프트 구성
LLM 응답 중 “스토리 텍스트”와 “상태 업데이트 JSON” 분리
FLock API Client
OpenAI compatible client로 Qwen 호출
Onchain Module
던전 클리어 시 Base NFT 민팅 Tx 생성
(간단한 ERC-721 구현)
AgentFS 구조 예시
/world/{wallet}/{runId}/
  world.md              # 이 던전의 세계관/설정 요약
  state.json            # 현재 스탯, 위치, 체력 등
  log/
    0001_intro.md
    0002_first_room.md
    0003_battle_slime.md
  inventory.json        # 아이템 리스트
  meta.json             # 난이도, 시작시간, 종료시간, 엔딩타입
1-3. FLock 프롬프트 설계
1) 월드 생성
const system = `
You are a Dungeon Master for a text-based roguelike game.
You must output JSON with:
- world_description
- initial_state (JSON)
- first_scene (narration + choices)
All content should be in Korean.
`;

const user = `
지갑 주소: ${walletAddress}
유저의 선호 장르: ${genrePreferences}
난이도: ${difficulty}

위 정보를 바탕으로 새로운 던전을 생성해줘.
`;

const res = await flock.chat.completions.create({
  model: "qwen-32b-instruct",
  messages: [
    { role: "system", content: system },
    { role: "user", content: user },
  ],
  response_format: { type: "json_object" },
});
2) 턴 진행 매 턴마다:
입력: state.json, 최근 로그 일부, 유저 입력
출력: "narration", "choices", "state_patch"
const system = `
You are continuing a rogue-like game as a Dungeon Master.
Input:
- current_state: JSON
- recent_log: bullet points (short)
- user_action: text

Output JSON:
- narration (Korean)
- choices (array of 2~4 options, each short)
- state_patch (JSON patch to apply to current_state)
- event_type (NORMAL | BATTLE | TREASURE | BOSS | DEATH | CLEAR)
`;

const user = `
current_state:
${JSON.stringify(currentState)}

recent_log:
${recentSummary}

user_action:
"${userInput}"
`;
1-4. KV Cache 활용
여기서 “KV Cache”는 월드/룰 프리픽스 캐시로 쓰면 됩니다.
한 번 월드 룰셋이 생성되면,
그 이후 턴들에서는 같은 시스템 프롬프트/배경 설정이 계속 반복됨.
전략:
world.md + 게임 룰 설명을 “고정 prefix prompt”로 보고,
이를 KV Cache로 간주 → 백엔드에서 sessionId 기반으로 “초기 context”를 한 번만 빌드하고 이후 요청은 짧은 delta만 붙이기.
구현 난이도:
실제 LLM 내부 KV를 만지긴 어렵지만,
프롬프트 레벨 캐싱으로 API 토큰/지연 줄이는 컴포넌트 구현은 간단.
예: prefixHash = hash(world.md + RULES) → Redis에 캐시하고, 동일 prefix면 재사용.
슬라이드/발표에서는:
“던전 월드 + 룰셋을 하나의 KV 캐시 프리픽스로 보고,
매 턴마다 delta 컨텍스트만 보내는 방식으로 설계했습니다.”
라고 설명하면 “KV Cache 감각 있는 팀” 느낌 납니다.
1-5. Base 연동 포인트 (NFT)
던전 클리어 or 특수 엔딩 도달 시:
meta.json + world.md + 요약 로그를 모아서 메타데이터 생성
이걸 IPFS 혹은 온체인에 일부 올려서 ERC-721 NFT로 민팅
Mini App에서 “내 클리어 기록” 탭에서 NFT 목록/메타데이터 표시
기술적으로는:
아주 간단한 NFT 컨트랙트 + Mint 함수만 구현하면 끝
가스는 Base라 매우 저렴
1-6. 왜 수상각인가?
신박함:
“LLM이 던전 마스터인 로그라이크” + “AgentFS를 진짜 게임 월드 DB로 사용”
보통은 그냥 LLM 대화 게임인데, 여긴 파일 시스템 레벨에서 stateful하게 설계.
구현 난이도:
사실상 “챗봇 + 상태 JSON 패치” 정도라 백엔드 로직은 단순함.
복잡한 알고리즘 없이도, 룰을 잘 설계한 프롬프트로 꽤 그럴듯한 게임 나옴.
FLock 활용도:
세계관 생성, 이벤트 생성, 상태 업데이트 판단 → LLM을 계속 활용
Base & Web3 요소:
지갑 = 저장 슬롯
클리어 기록 = NFT
나중에 여러 유저의 월드를 합치는 메타게임도 가능
아이디어 2
🐣 x402 AI Tamagotchi — 스스로 공부하고 결제하는 온체인 AI 펫
지갑 안에 “AI 펫”이 하나 살고 있음
모든 기억과 성격은 AgentFS에 저장된 파일들
대화할수록 FLock/Qwen이 펫의 성격/말투/지식을 업데이트
펫이 자기 성장 위해 웹 지식·API를 x402로 직접 결제해서 가져옴
유저는 “예산 캡”만 지정 → 진짜로 돈 쓰는 AI 펫
특정 성장 단계마다 Base NFT로 “펫 성장 스냅샷” 민팅
이건 그냥 들으면 “뭐야 이 미친 컨셉은 ㅋㅋ” 하면서도, 기술 요소는 정석으로 다 들어가 있습니다.
2-1. 사용자 플로우
Base 지갑 연결 후 Mini App 접속 (혹은 일반 dApp + x402)
“새 펫 생성”:
펫 이름, 기본 성격(쫄보, INFJ, 장난꾸러기 등), 언어 선택
초기 파일 구조 생성:
/pet/profile.json
/pet/memories/
/pet/skills/
채팅으로 펫과 이야기:
“너는 누구야?”, “오늘 나 기분 안 좋아”, “이 논문 좀 대신 읽어줘”
펫이 자기 한계를 느낌:
“이건 잘 몰라. 인터넷에서 좀 공부해볼게. 0.1 USDC 써도 될까?”
유저가 “OK”하면,
펫이 x402로 유료 API/웹 데이터 결제 → 데이터 intake
그 내용을 요약해서 자기 /pet/knowledge/ 파일에 저장
펫의 레벨/스킬:
많이 공부할수록 “번역 잘함”, “코딩 잘함”, “책 요약 잘함” 같은 스킬 메타데이터 추가
AgentFS에 skills.json 로 관리
특정 레벨 단계:
예: Level 5 달성할 때마다 Base NFT로 “성장 스냅샷” 민팅
그 시점의 personality summary, skills, 주요 기억 요약 포함
2-2. 아키텍처
프론트
React + 지갑 연결
화면:
메인 채팅
펫 상태 패널 (레벨, 기분, 최근 배운 것)
예산 설정 슬라이더 (오늘 펫이 쓸 수 있는 USDC)
성장 히스토리 / NFT 목록
백엔드
Node.js / FastAPI
모듈:
Pet Engine
유저 ↔ 펫 대화 처리
FLock(Qwen) 프롬프트 설계
“지금은 모르는 내용인지?” 판단 → 공부 필요 여부 결정
Knowledge Fetcher
외부 API(검색/news/위키 등) 호출
x402 기반 pay-per-call
AgentFS Manager
/pet/** 디렉토리 관리
기억/지식/스킬 업데이트
Budget Manager
오늘 사용 가능 USDC, 누적 사용량 추적
AgentFS 구조 예시
/pet/
  profile.json        # 이름, 나이(?) 설정, 성격, 생성일 등
  memories/
    2025-11-21.md     # 대화 요약 & 감정 상태
    2025-11-22.md
  knowledge/
    crypto.md         # 크립토 관련 배운 것
    web3.md
    cooking.md
  skills.json         # { "translation": 3, "coding": 2, "summarization": 4 }
  meta.json           # level, exp, 오늘 남은 예산 등
2-3. FLock 프롬프트 설계
1) 기본 대화/성격 유지
const system = `
You are an AI pet living in a wallet. 
You have a persistent memory and a personality.
Always speak in Korean, in a friendly, slightly playful tone.

You receive:
- pet_profile: JSON
- recent_memory_summary: text
- current_skills: JSON

You must:
- reply to the user in character
- decide whether you know enough to answer or you need to "study" more.
- if you decide to study, you must output study_plan in JSON.

Output JSON:
{ 
  "reply": "...",
  "need_study": true/false,
  "study_plan": { ... optional ... },
  "updated_emotion": "happy|sad|curious|tired"
}
`;
2) 공부(Study) 결정 시
need_study: true && 예산 내 → Knowledge Fetcher가 동작
Qwen에게 study_plan을 다시 넘겨, 어떤 키워드/소스를 볼지 정리하게 함
외부 API (예: 뉴스/위키/검색) 호출 후, 그 결과를 다시 FLock에 넣어 “펫의 지식 파일 업데이트용 요약” 생성
2-4. x402 통합
외부 API들 (예: 고급 뉴스, 논문 검색, 코드 분석 API 등)을 x402 paywall 뒤에 둔다고 가정
흐름:
Knowledge Fetcher가 유료 API 엔드포인트 호출
402 Payment Required 응답 수신
x402 미들웨어를 통해 유저 지갑(or 펫 전용 서브 지갑)에서 USDC 소액 결제
결제 후 실제 데이터 수신 → LLM에 전달 → 요약/지식화
유저는 UI에서:
“오늘 펫이 학습에 쓴 금액: 0.23 USDC”를 실시간으로 확인
예산 제한: “오늘 최대 0.5 USDC 이상 쓰지 마” 등 설정
포인트
단순히 x402를 “API 사용료 결제”에 쓰는 것을 넘어,
**“AI가 자기 성장 위해 돈을 쓰는 패턴”**을 보여준다는 게 신박 포인트입니다.
2-5. KV Cache 활용
여기서 KV Cache는 펫의 skill-specific context에 쓰기 좋습니다.
예:
펫이 “번역 스킬”이 3 이상이면,
자주 쓰는 번역/스타일 프롬프트를 prefix로 캐시
펫이 “코딩 스킬”을 사용할 때:
코딩 설명 시스템 프롬프트 + 코딩 스타일 예시를 cache 프리픽스로 잡고
매 요청마다 delta만 붙여서 LLM 호출
구현:
contextProfileHash = hash(skillConfig + personaPrompt)
이 hash 기준으로 LLM 호출 결과의 일부를 프롬프트 캐시로 재사용
슬라이드에서:
“펫의 스킬/성격을 하나의 KV 캐시 프리픽스로 보고,
거기에 유저 입력만 델타로 추가하는 구조”
라고 정리하면 자연스럽게 KV Cache 얘기를 기술적으로 끼워넣을 수 있음.
2-6. Base 연동
펫의 성장 단계별 스냅샷 NFT:
Level 1, 5, 10 … 등의 특정 레벨에서:
profile, skills.json, 최근 기억 요약을 한 번 더 요약해서 메타데이터에 넣고
“이 시점의 펫”을 Base NFT로 민트
여러 펫을 동시에 운영 가능:
/pet/{petId}/…로 디렉토리 분리
각 펫은 별도 NFT로 관리
나중에:
다른 유저에게 펫 NFT를 양도하면?
AgentFS의 snapshot ID도 같이 넘겨서 “기억까지 이동하는 펫”
2-7. 왜 수상각인가?
들었을 때 임팩트 있음
“돈 쓰는 AI 다마고치”
“지갑 속에 사는 AI 펫이 x402로 자기 공부를 위해 결제한다”
심사위원/관객이 바로 이해하고 웃으면서도, 기술 구성은 탄탄함.
구현 난이도
기본 구조는 사실: 챗봇 + 파일 저장 + API 호출 + x402 통합
AgentFS와 x402 모두 예제/SDK가 있어, 해커톤 기간에 충분
FLock 활용도
성격/대화/지식 요약/공부 플랜까지 전부 LLM이 담당
Multi-step chain (대화 → 학습 여부 결정 → 외부 데이터 → 지식화)
창의성/실용성
창의성: 말할 것도 없음
실용성: 단순 펫에서 끝내지 않고,
“내 프로젝트에 대한 AI 리서치 에이전트”
“내 코드를 대신 공부하는 코딩 펫” 등으로 바로 확장 가능
마무리
요약하면:
AgentFS Dungeon
LLM이 던전 마스터인 로그라이크
AgentFS = 게임 월드/상태 DB
Base NFT = 클리어 기록
KV Cache = 월드/룰 프리픽스 캐시
x402 AI Tamagotchi
자기 성장 위해 x402로 API 결제하는 AI 펫
AgentFS = 펫의 뇌/기억/스킬 저장소
FLock(Qwen)이 성격/대화/학습 전체 컨트롤
Base NFT = 성장 스냅샷
둘 다 “듣자마자 콘셉트가 확 박히고”,
구현은 챗봇 + 파일시스템 + 약간의 온체인 로직 + x402 수준이라
해커톤 기간 내에 충분히 MVP를 만들 수 있습니다. 원하시면 둘 중 하나 골라서
실제 폴더 구조
API 스펙
FLock 호출용 TypeScript 예시 코드
까지 바로 쪼개 드릴게요.
You said:

FLock.io 플랫폼이 연합학습 플랫폼이라는데 Kv Cache 저거랑 잘 묶어서 연결고리 만들어볼 수 있지 않을까 싶네요

뭔가 RL로 포켓몬 하고 그런거 오픈솟 ㅡ많을텐데 이런거 활용해서 좀 더 생각해볼까
ChatGPT said:
맞아요, **“FLock = 연합학습 + 블록체인”**이고, 여기에 KV Cache / C2C 개념이랑 포켓몬 RL 오픈소스를 엮으면 꽤 맛있는 스토리 나옵니다.
“이 팀은 논문/인프라 스택 다 알고 있다” 느낌 나는 쪽으로 두 개만 딱 잡아볼게요.
아이디어 1
🐤⚔️ FLoCKémon FedLeague – 연합학습 + KV 캐시로 돌리는 포켓몬 RL 리그
한 줄 요약
“여러 지갑 유저들이 각자 포켓몬 RL 에이전트를 돌려서 데이터를 모으고,
그 경험을 FLock 연합학습/AI Arena 스타일로 모아 **공유 정책(Policy)**를 키우고,
전 세계가 같이 키운 ‘집단 뇌’를 가지고 포켓몬 쇼다운 리그를 여는 Base Mini App.”
컨셉 연결고리 정리
연합학습 (Federated RL)
각 유저가 로컬에서 포켓몬 환경을 굴려서 RL 경험(trajectory)을 쌓고,
원본 로그는 로컬에 남긴 채, 요약된 통계/gradient만 FLock 쪽 “집단 모델”에 기여하는 구조.
CoinMarketCap
+2
Messari
+2
KV Cache (C2C / KVComm 느낌)
포켓몬 전투에서의 “상태(state) → 행동(action)”을 키-값으로 보는 관점.
상태를 임베딩/요약해서 **“anchor KV”**로 저장하고, 다른 유저 에이전트가 비슷한 상태에 왔을 때 이 KV를 재사용 (C2C에서 말하는 cross-context KV reuse를 RL로 번역).
CoinEx
+1
포켓몬 RL 오픈소스
예: poke-env + Pokémon Showdown Gym wrapper, Stable Baselines3 같은 준비된 환경/알고리즘들.
arXiv
+5
Poke-env
+5
GitHub
+5
FLock + Base
FLock은 원래 게임 기반 AI Arena 같은 탈중앙 AI 트레이닝도 하고 있고, Base 위에 gmFLOCK 스테이킹/참여 구조도 이미 있음 → “게임 + RL + 연합학습” 스토리 깔끔하게 들어감.
train.flock.io
+2
Flock
+2
1-1. MVP로 실제 해커톤에서 구현할 부분만 콕 집어보면
RL 풀스택 다 구현하려고 하면 터집니다. 그래서 해커톤 버전은:
프론트: Base Mini App
유저는 지갑 연결 → “내 포켓몬 AI 팀” 생성.
화면:
현재 전투 화면(텍스트/간단 UI)
“AI가 자동으로 플레이” / “수동 조작” 토글
‘글로벌 정책 버전(집단 뇌 버전)’ vs ‘내 로컬 정책’ 비교
백엔드: 간단한 RL + FLock + KV 캐시
환경
서버에서 Python으로 poke-env를 돌려서 Pokémon Showdown 스타일 배틀 환경 제공.
Poke-env
+2
GitHub
+2
Node 백엔드가 이 환경을 HTTP로 감싸서 “현재 상태 JSON”을 반환.
정책(Policy) 두 층
글로벌 정책 (전 세계 공유 뇌)
FLock API(=Qwen 같은 LLM)에게 “현재 상태 → 추천 행동” 묻게 함.
상태는 텍스트/구조화 JSON으로 요약해서 prompt로 보냄.
로컬 경험 기반 정책
각 유저별로 AgentFS/SQLite에 stateKey → actionStats 테이블을 유지
많이 이긴 행동에 가중치를 더 주는 가벼운 tabular Q-learning 느낌.
KV 캐시 역할
stateKey = hash(상태 요약 or state embedding)
KV[stateKey] = { action_probs, value_estimate, play_count }
다른 유저가 비슷한 상태에 도달하면,
FLock LLM을 부르기 전에 KV 캐시를 먼저 보고 reuse
캐시가 없는 경우에만 LLM 호출 → LLM 결과를 KV로 저장 (C2C anchor처럼).
CoinEx
+1
연합학습 맛만 살리기
“연합학습”을 완전히 구현하기보다는,
각 유저는 raw trajectory는 로컬 AgentFS에 저장하고,
서버에 보내는 건 stateKey, chosenAction, win/loss 같은 요약 스탯 뿐.
서버는 이걸 모아서 글로벌 KV 테이블 업데이트:
global_kv[stateKey].wins[action]++;
global_kv[stateKey].visits[action]++;
LLM도 주기적으로 이 global_kv를 읽어서:
“이 state 패턴일 때는 이 액션이 승률 높더라” 같은 요약을 만들어
다음 프롬프트에 반영 → 약간의 “연합학습 + policy improvement” 느낌.
→ 이렇게 하면, 진짜 FL Alliance / AI Arena에 붙이는 full federated RL까지는 아니더라도,
**“각 유저의 경험이 곧 글로벌 KV policy로 모인다”**는 스토리가 성립합니다.
Flock
+3
CoinMarketCap
+3
Messari
+3
1-2. Base / x402 쪽 포인트
Base
Mini App UI + 지갑 주소 = “에이전트 ID”
각 전투의 결과 / 상대 / 사용한 글로벌 정책 버전 정보를 Base 컨트랙트에 기록해서:
퍼블릭 리더보드, 시즌 포인트
“이 주소는 글로벌 뇌에 어느 정도 기여했는지” 지표
(옵션) x402
진짜로 AI 자동 플레이 사용 시 한 판당 0.01 USDC 같은 마이크로 결제 구조:
사용자가 “Auto-play” 누르면 백엔드 LLM 호출 전에 x402로 결제 요구 (402)
받는 돈은:
일부: FLock API 비용
일부: 글로벌 KV policy에 많이 기여한 상위 N명의 지갑으로 분배 → “연합학습 기여자 리워드” 스토리 완성.
1-3. 실제 코드/구현 난이도 관점
어려운 부분:
poke-env / PokemonShowdown 연동 (Python 서버 + 브리지) — 하지만 예제가 많음.
cs230.stanford.edu
+3
Poke-env
+3
GitHub
+3
쉽게 갈 수 있는 타협:
완전한 포켓몬이 아니라,
4개 스킬 중 하나 고르는 간단한 턴제 텍스트 배틀으로 축소해도 충분히 컨셉 살아남.
핵심은:
상태 요약 → KV 캐시 → FLock LLM → 글로벌 통계로 policy 개선
이 파이프라인을 “연합학습 + KV reuse”로 포장하는 것.
아이디어 2
🧠📚 FedRL Coach Studio – RL 포켓몬 플레이 로그를 연합학습 + KV 캐시로 씹어서 “전략 사전” 만드는 스튜디오
한 줄 요약
“포켓몬 RL 에이전트를 돌리는 사람들 로그를 모아,
각 ‘상황(state)’별로 자연어 전략 설명 + 추천 행동을 FLock/Qwen이 만들어주는 스튜디오.
이 전략들을 KV 캐시처럼 공유해서, 새로운 에이전트나 사람도 바로 써먹게 하는 Base + x402 툴.”
이번 건 “게임을 직접 보여주는 리그”가 아니라,
**RL 하는 사람들을 위한 ‘코치/리뷰 스튜디오’**에 가깝습니다.
2-1. 플로우 요약
사용자 측 (RL 개발자/연구자)
이미 포켓몬 RL 코드를 돌리고 있음 (poke-env + stable-baselines3 튜토리얼 그대로).
cs230.stanford.edu
+4
Poke-env
+4
Hamish Ivison
+4
에피소드 로그(상태, 액션, 보상, done)를 JSON/Gym rollouts 형태로 export.
우리 앱에 업로드 (또는 API로 연동)
Base Mini App / 웹에서 RL 로그 zip/json 업로드.
지갑 주소 기준으로 “내 실험 세션” 관리.
FLock/Qwen이 하는 일 (코치 역할)
로그를 쪼개서,
비슷한 state들을 clustering (임베딩 or 단순 discretization)
각 state cluster마다:
“이런 상황에서는 어떤 행동들이 있었고, 어떤 행동이 높은 reward를 줬는지”
“잘못된 행동 패턴은 뭐였는지”
→ 이걸 FLock LLM에게 설명시켜서 자연어 전략 카드로 만든다.
예:
“상대가 물 타입이고, 우리 체력이 30% 이하, 상대 스피드는 더 빠른 상황에서는 방어 또는 교체가 평균 승률을 25% 올려줌.”
KV 캐시 구조화
각 전략 카드를 KV로 저장:
key = hash(상태요약 특징벡터)
value = { 설명 텍스트, 추천 행동 분포, 예시 에피소드 링크 }
이 KV들을 Base나 IPFS에 인덱스/해시로 올려서 “공유 전략 뇌”처럼 활용.
재사용
다른 RL 유저나 사람 플레이어가:
현재 게임 상태를 요약해서 보내면
KV에서 가장 비슷한 state 찾고 (최근접 탐색 / 단순 키 룩업)
거기 저장된 전략 설명 + 추천 액션을 바로 보여줌.
즉, “RL 로그로부터 뽑아낸 사회적/집단적인 전략 사전”.
2-2. 연합학습(FL) + FLock 스토리
각 RL 유저는:
로컬에서 에이전트 훈련 (자기 GPU/노트북)
원본 데이터는 그대로 보유
우리 서비스에 올라오는 건:
이미 익명화된 state-feature, action, reward 로그
혹은 더 나아가면 각 사용자가 local에서 state clustering + 통계까지 수행하고
요약 통계만 업로드 → 진짜 FL에 가까워짐.
FLock와의 연결:
FLock는 원래 개인 데이터를 로컬에 두고 FL 방식으로 글로벌 모델을 만드는 플랫폼이라, 우리는 “RL 경험을 활용해 Qwen 기반 전략 서머라이저를 튜닝하는 데이터 파이프라인”으로 이야기 구조를 짤 수 있음.
Bybit Learn
+4
CoinMarketCap
+4
Flock
+4
해커톤에서는 실제 튜닝까지는 못 가도:
FLock의 API Platform(Qwen 서빙)을 써서
이 전략 요약/설명 생성 부분을 모두 FLock 위에서 돌림.
eblockmedia.com
+3
Flock
+3
Flock
+3
2-3. 구체 아키텍처
1) 백엔드 파이프라인
입력: 여러 유저의 RL log ((s_t, a_t, r_t, s_{t+1}) 시퀀스)
Step A: 상태 임베딩 or 특징 추출
간단히는:
포켓몬 상태를 “내 포켓몬 타입/HP, 상대 타입/HP, 날씨, 부가 효과…” 같은 카테고리 피처로 변환.
좀 더 욕심 내면:
FLock embedding API (OpenAI-style)로 텍스트 설명을 벡터화.
Flock
+1
Step B: 클러스터링
K-means or simple hash bucketing (상태를 discretization).
클러스터별로:
액션 분포, 평균 이득/손해 계산.
Step C: 전략 카드 생성 (FLock LLM)
for each cluster C:
    summary = {
        "state_description": templated_english_or_korean_state(C),
        "action_stats": action_stats(C),
        "example_episodes": pick_few_examples(C)
    }
    prompt LLM (FLock/Qwen):
        "이 요약을 읽고, 사람에게 설명하듯 전략 팁을 써줘"
    -> strategy_card.md
Step D: KV 캐시 테이블로 저장
key = hash(cluster_centroid_features)
value = { strategy_card, action_stats, centroid_vector }
저장 위치:
오프체인: AgentFS/SQLite
온체인: key + 짧은 메타 해시만 Base 컨트랙트에 기록.
2) 실시간 코치 API
호출 인터페이스:
POST /coach with 현재 state
내부:
state → feature → cluster (가까운 centroid 선택)
KV에서 전략 카드 로딩 (캐시 hit)
없으면 FLock LLM에게 on-the-fly 요약 생성 후 KV에 저장 (lazy-building)
결과를 Mini App에 반환 (텍스트 설명 + 추천 행동 리스트)
2-4. x402 활용
이건 **“RL 결과/전략을 서비스로 파는 구조”**로 연결하기 좋습니다.
/coach API를 x402 paywall 뒤에 둠:
한 state 문의당 0.001~0.01 USDC.
RL 팀/연구자들이 자기 에이전트 디버깅/튜닝할 때 많이 부를 수 있음.
받은 돈의 일부는:
해당 전략 카드 생성에 기여한 로그 제공자(지갑 주소)에게 배분:
클러스터마다 “기여도(해당 로그가 차지한 비율)”를 저장해두고,
요청 발생 시 x402 수익 분배.
→ 이러면 자연스럽게:
“RL 로그를 업로드해서 전략 사전 형성에 기여하면,
이후 다른 사람들이 그 사전을 쓸 때마다 x402로 자동 수익배분 받는 구조”
가 나옵니다. (FLock의 “데이터/모델 기여자에게 토큰 인센티브” 철학과도 딱 맞음).
CoinMarketCap
+2
CoinEx
+2
2-5. KV Cache / C2C 논문 스토리 끼워 넣기
발표 때 이렇게 프레임:
C2C / KVComm 계열 연구는 여러 LLM 에이전트가 KV cache를 공유해서 성능과 지연을 개선하는 방법을 제안.
CoinEx
+1
우리는 RL state → 전략/설명을 KV로 보고,
여러 유저 에이전트가 이 KV를 공유/재사용하게 함으로써
사실상 RL에서도 “cross-agent KV reuse”를 구현했다는 식으로 말할 수 있음.
심사위원 관점에서:
“연합학습 + RL + KV cache + Base + x402 다 알고 엮었네?” 하는 포인트.
정리
당신이 말한:
FLock = 연합학습 플랫폼
KV Cache / C2C 같은 최신 LLM infra 개념
포켓몬 RL 오픈소스
이 세 개를 진짜로 엮을 수 있는 방향으로 두 가지를 잡았습니다.
FLoCKémon FedLeague
플레이어들이 포켓몬 RL 환경에서 경험을 쌓고,
그 경험이 글로벌 KV 정책으로 모이는 연합 RL 리그
Base Mini App + (옵션) x402, FLock API는 정책/해설 LLM으로 사용.
FedRL Coach Studio
포켓몬 RL 로그를 모아 state별 전략을 자연어 카드 + KV 캐시로 만드는 스튜디오
RL 연구자/개발자가 자기 에이전트 디버깅/튜닝에 쓰고,
x402로 “전략 사전 API” monetization + 기여자 수익 분배.
둘 다 컨셉은 꽤 미친(?)데, 실제 구현은 “LLM + 간단한 통계 + KV 테이블 + Base/x402” 수준이라 해커톤에서 충분히 가져갈 수 있는 라인입니다. 원하면 이 중 하나 골라서:
어떤 부분을 “실제로 구현”하고
어떤 부분을 “향후 확장/연합학습 방향”으로 발표에서만 설명할지
딱 쪼개서 구체적인 TODO 리스트/레포 구조까지 잡아줄게요.
You said:
CIlIo — 오전 10:28
아무튼 근데 2번도 다시 읽어보니 포켓몬이네요
1번도 2번도 포켓몬 ㅋㅋㅋ 포켓몬이 들어가야 하는 거였나요?
Sigrid Jin

 — 오전 10:45
아뇨 그냥 가벼운 게임 ㅋㅋ
을 해서 관심 끌어보자였는데
테트리스도 좋구요
CIlIo — 오전 10:46
아하
Sigrid Jin

 — 오전 11:02
가장 간단하 게임이면 테트리스 도 좋고 팩맨도 좋아보입니다

2번으로 해서 구체적으로 빌딩해주세요 
ChatGPT said:
좋아요, 그럼 **“2번 아이디어”를 포켓몬 대신 가벼운 게임(테트리스/팩맨 계열)**로 바꿔서
해커톤에 바로 쓸 수 있게 구체적인 설계까지 한 번에 빡세게 깔아볼게요. 제가 아래에서 빌드할 2번은:
FedRL Game Coach Studio (테트리스 버전)
= “연합학습 + KV Cache + RL + FLock/Qwen + Base Mini App”를
간단한 테트리스 게임 데모로 보여주는 프로젝트
로 잡겠습니다.
0. 한 줄 피치 / 발표용 문장
“지갑마다 테트리스 플레이 로그를 모으고,
FLock/Qwen이 그 로그를 씹어서 ‘전략 사전’을 만들어줍니다.
비슷한 판이 다시 나오면 LLM을 다시 돌리지 않고
KV Cache에서 전략을 바로 꺼내 쓰는,
연합학습·KV 캐시 기반 테트리스 코치 스튜디오입니다.”
Light & Fun: 실제로 미니 테트리스 게임이 돌아가고, 옆에서 AI가 코치해줌.
Tech Story: 연합학습 느낌 + KV 캐시 + FLock API + Base Mini App 다 들어감.
구현 난이도:
프론트: 브라우저 테트리스 (수많은 JS 예제 있음)
백엔드: 상태→전략 요약은 FLock API 호출 + KV 테이블
RL/연합학습은 “로그 분석 + 통계 + 요약” 정도로 마무리
1. 유저 경험 (UX 플로우)
1) 지갑 연결 & 프로필 생성
Base Mini App 접속 → 지갑 연결.
닉네임, 난이도(초보/중수/고수), 플레이 스타일(공격적으로 쌓기 vs 안정적으로 쌓기) 선택.
이 정보는 백엔드에서 players/{wallet}/profile.json에 저장 (AgentFS/SQLite).
2) 테트리스 게임 + 실시간 AI 코치
화면 구성:
좌측: 실제 테트리스 보드 (JS 캔버스)
우측 상단:
현재 점수, 레벨, 남은 시간 등
우측 하단: AI 코치 패널
현재 판에 대한 한줄 코멘트
“추천 조작” (왼쪽/오른쪽/회전/하드드롭 등)
최근 N턴 전략 히스토리
플레이 흐름:
유저가 테트리스 플레이 (키보드 입력).
매 N 프레임 또는 블록이 바닥에 닿을 때마다:
현재 보드 상태를 압축된 2D 배열/텍스트로 백엔드에 전송.
백엔드는 이 상태를 보고 AI 코치 의견을 반환:
“지금은 오른쪽에 T-spin 준비를 위해 이쪽에 쌓는 게 좋아요.”
“왼쪽 빈 구멍 채우는 게 우선입니다.” 같은 식.
유저는 이 코치를 참고해서 플레이를 개선 → 재미 + 교육.
3) 플레이 로그 업로드 & 분석
한 판이 끝나면:
해당 판의 전체 상태 시퀀스 + 유저의 실제 액션 + 점수가
자동으로 서버에 업로드되어 replays/{wallet}/{runId}.json으로 저장.
유저는 “분석 보기” 버튼을 눌러:
“이 판에서 실수 많이 한 패턴”
“고수 플레이어들은 이 상황에서 이렇게 했다”
같은 분석 리포트를 볼 수 있음.
4) “전략 사전” 재사용 (KV Cache)
여러 플레이어의 로그를 모아서 만들어진 전략 카드들은
“비슷한 판”에서 다른 유저에게도 재사용됨.
예: “왼쪽에 1×N 구덩이가 있고, 오른쪽이 울퉁불퉁한 mid-height” 같은 판은
이미 KV에 “이때는 I블록을 오른쪽에 꽂고 왼쪽을 정리해라”가 들어있으면 LLM 없이 바로 사용.
2. 아키텍처 개요
2-1. 전체 구성도 (텍스트 버전)
Frontend (Base Mini App)
Next.js + Base Mini App SDK
테트리스 Canvas 게임
AI 코치 패널 + 리플레이/분석 뷰
Backend (Node + Python)
game-api (Node):
상태 수신, FLock API 호출, KV 캐시 조회
리플레이/플레이어 관리
analysis-worker (Python or Node):
리플레이 파일을 뭉쳐서 상태 클러스터링
FLock/Qwen으로 전략 카드 생성
Storage
AgentFS/SQLite (혹은 Turso)
players.db, replays.db, kv_cache.db
(옵션) Blob Storage/IPFS: 리플레이 raw 데이터
Onchain (Base)
GameStats 컨트랙트:
지갑별 최고 점수 / 플레이 횟수 / 전략 기여도 등 기록
나중에 “전략 기여 상위 N명”에게 보상 주는 구조까지 확장 가능
3. 데이터 모델 / KV Cache 설계
3-1. 상태 표현 (Tetris State)
Tetris Gymnasium 같은 RL 환경들이 쓰는 패턴을 그대로 따라가면 됩니다:
Kaggle
+5
GitHub
+5
Reddit
+5
 예시:
type TetrisState = {
  board: number[][];   // 0=empty, 1~7 = tetromino ID
  currentPiece: number;
  currentRotation: number;
  currentX: number;
  currentY: number;
  nextQueue: number[]; // 다음 3~5개 블록
  holdPiece: number | null;
  combo: number;
  backToBack: boolean;
  level: number;
};
이를 정규화된 문자열로 바꿔서 해시 키 생성:
const normalizeState = (s: TetrisState) => JSON.stringify({
  board: s.board,             // 너무 크면 높이 4~8줄만 사용
  currentPiece: s.currentPiece,
  nextQueue: s.nextQueue.slice(0, 3),
  holdPiece: s.holdPiece,
  levelBucket: Math.floor(s.level / 3),
});

const stateKey = keccak256(normalizeState(s)); // or SHA-256
3-2. KV Cache 엔트리
type StrategyEntry = {
  recommendedAction: "LEFT" | "RIGHT" | "ROTATE" | "DROP" | "HOLD";
  explanation: string;           // Qwen이 뱉은 코멘트
  actionStats: { [action: string]: { count: number; avgScoreDelta: number } };
  lastUpdatedAt: number;
  visits: number;                // 이 stateKey가 얼마나 자주 등장했는지
};
첫 등장 시:
FLock/Qwen한테 한 번 물어보고, recommendedAction + explanation 채우기.
actionStats는 빈 상태로 시작.
이후 플레이어들이 동일 상태에서 실제로 뭘 했는지를 로그로 채우면서
actionStats / visits 업데이트 → 점점 더 데이터 기반 코치가 됨.
4. FLock/Qwen 활용 방식
FLock API Platform은 OpenAI SDK 호환이기 때문에,
기존 OpenAI 클라이언트 코드에서 baseURL만 갈아끼우면 됩니다.
Flock
+2
Flock
+2
4-1. 한 상태에 대한 전략 코멘트 생성
const client = new OpenAI({
  baseURL: "https://api.flock.io/v1",   // 예시
  apiKey: process.env.FLOCK_API_KEY,
});

const systemPrompt = `
You are a Tetris coach AI.
Given the current board state and possible actions,
you suggest the best action and explain why.
Return JSON only.
`;

const userPrompt = `
Current state (JSON):
${normalizeState(state)}

Possible actions: ["LEFT", "RIGHT", "ROTATE", "DROP", "HOLD"]

Player skill: ${playerProfile.level} (${playerProfile.style})

Please respond as:
{
  "recommendedAction": "...",
  "explanation": "..."
}
`;

const completion = await client.chat.completions.create({
  model: "qwen3-32b-instruct", // 실제 FLock에서 제공하는 Qwen3 계열 이름으로 교체
  messages: [
    { role: "system", content: systemPrompt },
    { role: "user", content: userPrompt },
  ],
  response_format: { type: "json_object" },
});
Qwen3는 reasoning + instruction-following이 좋아서 이런 structured JSON 응답에 적합하고,
“생각 모드/빠른 모드”를 설정할 수 있어 복잡할 땐 깊게, 단순할 땐 빠르게도 가능하다고 알려져 있습니다.
Hugging Face
+4
Qwen
+4
arXiv
+4
4-2. 리플레이 요약 / 전략 카드 생성
여러 상태/액션/스코어 로그가 쌓이면, 배치 작업에서:
비슷한 상태들을 clustering (간단히는 board pattern 기준으로 bucket).
각 클러스터별로:
가장 많이 나오는 실수 패턴
고득점 플레이어들이 선택한 행동
이 요약 정보를 Qwen에 넣어 사람이 읽기 좋은 전략 카드 생성:
- "왼쪽에 깊은 구멍이 있고 오른쪽은 완만한 지형일 때는,
   구멍을 메우는 걸 우선으로 하고, I블록은 꼭대기에서 쓰지 마라."
- "연속 콤보보다 필드 정리가 우선인 패턴"
이를 /strategies/{clusterId}.md 같은 파일로 AgentFS에 저장해두고,
프론트에서 “전략 사전” 페이지로 보여주면 됩니다.
5. 연합학습(Federated) 스토리 입히기
실제 FLock의 FL 파이프라인까지 구현하긴 어렵지만,
개념적으로 연합학습처럼 보이게 만드는 건 가능합니다:
각 지갑(플레이어)은:
로컬(=개인) 플레이를 통해
state_key, chosen_action, score_delta 로그를 생산하는 “클라이언트”
서버/분석 파이프라인은:
이 로그들을 모아 “글로벌 KV 전략 테이블”을 업데이트하는 “서버”
KV 테이블이 사실상 전 세계 플레이어들의 경험이 쌓인 글로벌 정책/코치 역할
발표할 때:
“각 플레이어는 자기 브라우저에서 플레이를 하고,
그 경험이 전부 글로벌 KV 전략 테이블에 반영됩니다. 다음에 다른 플레이어가 비슷한 판에 도달하면
그 사람이 FLock/Qwen을 직접 부르는 게 아니라
이미 축적된 전략을 캐시에서 꺼내 쓰게 되죠. 그래서 이 시스템은 **‘연합학습된 테트리스 코치’**입니다.”
라고 말하면, FLock의 “분산 학습 + 집단 모델” 스토리와 딱 맞습니다.
GitHub
+2
THE BEST - Manuel Goulão
+2
6. 해커톤용 최소 기능 세트 (MVP 컷)
1) Day 1–2
Next.js + Base Mini App 퀵스타트로 스캐폴딩.
아주 기본 테트리스 JS 게임 붙이기 (로컬에서 혼자 잘 도는 수준).
상태 스냅샷을 백엔드로 전송하는 API (POST /state) 연결.
2) Day 3
FLock API 연결: POST /coach에서
FLock/Qwen 호출 → recommendedAction + explanation 반환.
프론트에서 우측에 “AI 코치 패널”로 띄우기.
3) Day 4
간단한 KV Cache (SQLite/AgentFS) 구현:
state_key 기반 KV 테이블
cache hit 시 FLock 호출 생략
한 판 끝나면 /replay 엔드포인트로 로그 저장.
4) Day 5
리플레이 분석 배치 잡:
한 판 기준 “실수 구간 Top 3” 요약
FLock에게 리포트 텍스트 생성 시키기.
프론트에서 “내 리플레이 분석 보기” 페이지 구현.
5) Day 6
Base 컨트랙트:
submitGameResult(score, linesCleared, contributedStates)
저장하는 매우 얇은 GameStats 컨트랙트 작성.
Mini App에서 게임 종료 시 Tx 발행 → 리더보드 뷰.
6) Day 7
데모 시나리오 + 5분 영상:
지갑 연결 → 짧은 소개
테트리스 플레이 & AI 코치 실시간 코멘트
리플레이 분석 리포트 보기
리더보드 / “전략 기여도” 보여주기
“이게 연합학습 + KV Cache + FLock + Base”라는 메시지로 마무리
이렇게 가면:
게임은 가볍고 (테트리스)
내용은 기술적으로 신박하고 (연합학습 + KV Cache + RL 로그)
구현 난이도는 해커톤 기간 안에 충분히 가능
FLock/Qwen, Base, KV Cache 연결고리도 아주 깔끔
이라서 “듣자마자, 보고 나서도 수상 각”이 꽤 나올 거예요. 원하면 다음 단계로는:
실제 폴더 구조 (/frontend, /backend, /analysis)
DB schema (kv_cache, replays, players)
그리고 FLock 호출용 TypeScript 코드 템플릿까지
한 번에 뽑아드릴게요.
You said:
위 내용에서 해커톤 SWOT 분석하라
ChatGPT said:
해커톤 기준(완성도 / FLock 활용도 / 창의성 / 실용성) 관점에서
**“Base RL Coach Studio(테트리스/팩맨 계열 RL 코치 스튜디오)”**에 대해 SWOT 정리해볼게요.
🟢 Strengths (강점)
스토리텔링이 아주 명확함
“가벼운 게임 + AI 코치 + 연합학습 + KV 캐시”라는 한 문장 스토리가 있음.
데모 한 번 보면 바로 이해되는 구조라 데모데이 설명이 쉽고 임팩트 있음.
FLock / Qwen 활용도가 눈에 잘 보임
한 판 전체 로그를 먹여서:
플레이 요약, 실수 패턴, 전략 카드 생성 등 고급 자연어 분석을 다 FLock/Qwen으로 처리.
state 클러스터별 전략 카드도 전부 LLM이 만드는 구조라
→ “FLock API를 단순 챗봇 이상으로 쓴다”는 인상을 줄 수 있음.
KV Cache, 연합학습, RL 같은 “요즘 키워드”를 전부 건드릴 수 있음
RL 로그를 state/action/reward로 모으고,
비슷한 state를 하나의 key로 묶어 전략을 재사용하는 구조 → “semantic KV cache” 스토리.
플레이어별 로그는 로컬(AgentFS)에, 중앙에는 집계 통계만 모으는 형태 → “FL-ready 데이터 구조”라고 말할 수 있음.
기술 심사자 입장에서 “스택 감각 있는 팀”처럼 보이기 좋음.
시각적으로 재미있고, 관객/심사위원 Hook이 강함
그냥 폼 돌리고 텍스트 출력하는 게 아니라 실시간 게임 화면 + 옆에 AI 코치 패널이 있음.
라이브 데모:
직접 게임함 → 2) 코치가 실시간으로 뭐라함 → 3) 끝나고 리포트 보여줌
이런 흐름이 데모에서 엄청 먹힘.
완성도 올리기 좋은 구조
핵심 MVP는 사실:
간단 게임 + 로그 수집 + FLock 한 번 호출 + 리포트 뿌리기.
그 위에 클러스터링/전략 KV/리플레이 분석 등은 “있으면 좋고, 일부만 구현해도 강하게 어필 가능”한 확장 레이어라서,
우선순위 잘 잡으면 익스큐션 리스크를 관리하기 쉬움.
🔴 Weaknesses (약점)
구성 요소가 많아서 집중도가 흐를 수 있음
게임 + RL 로그 + 전략 클러스터링 + KV cache + FL 스토리 + (x402까지) 한 번에 넣으면,
발표 시간 5분 안에 모든 걸 설명하기가 빡셈.
해커톤에서는 메시지가 너무 많으면 “그래서 뭘 잘한 거지?”가 될 수 있음.
“연합학습”은 개념 단계에 머물 가능성이 큼
실제로 FLock FL 파이프라인까지 붙이진 못하고,
“이 로그 구조는 나중에 FL에 쓰기 좋다” 수준 설명이 될 확률이 높음.
심사위원 중에 엄밀한 사람은 “이걸 FL이라고 부를 수 있나?”라는 의문을 가질 수 있음.
실용성이 애매하게 보일 위험
게임 코치라는 게 직관적으로는 재밌지만,
“실제 유저/비즈니스 임팩트” 관점에서 좀 장난감처럼 보일 수 있음.
다른 팀이 기업형/생산성 툴을 가져오면, 비교될 때 “재미는 있는데 실제로 쓸까?”라는 질문이 나올 수 있음.
LLM 품질/지연에 따라 데모 퀄리티가 크게 출렁임
FLock 응답이 느리거나, 코멘트가 애매하면 “AI 코치 느낌”이 약해질 수 있음.
특히 실시간 추천(Tip)을 프레임마다 하려 하면 레이턴시 이슈 발생 → 설계를 잘 못하면 버벅이는 데모로 보일 수 있음.
🟡 Opportunities (기회)
“게임 + AI + Web3” 조합으로 차별화
대부분 팀이 문서 요약, 에이전트, 챗봇, 에디터, 코파일럿 같은 쪽으로 몰릴 확률이 높음.
그 사이에서 게임 속에서 돌아가는 FL + KV + LLM 코치는 확실히 눈에 띄는 포지션.
FLock의 게임/AI Arena 비전과 자연스럽게 맞물림
FLock 측은 원래 “커뮤니티가 같이 모델 키운다”, “AI Arena”류 그림을 좋아할 확률이 높음.
“전 세계 지갑이 테트리스/미로 게임 로그를 모아서, 하나의 집단 전략 뇌를 만든다”는 스토리는
스폰서 취향에도 잘 맞는 데모가 될 수 있음.
x402 결제/보상 구조로 확장 가능
Pro 코치 리포트, 고급 분석 기능 등에 x402를 붙여 pay-per-use 시나리오를 보여주면,
“AI · 데이터 · 결제 프로토콜까지 다 엮은 모델”로 이야기 확장 가능.
장기적으로는: 전략 KV에 많이 기여한 플레이어에게 수익 쉐어 구조 → 데이터 기여 인센티브 데모로 밀 수 있음.
게임을 바꾸기 쉬움
처음엔 블록 퍼즐, 나중엔 미로, 혹은 다른 오픈소스 간단 게임으로 손쉽게 확장 가능.
“RL 환경 하나만 지원”에서 “여러 미니게임 지원 스튜디오”로 자연스럽게 성장시킬 수 있음.
⚫ Threats (위협 요인)
다른 팀들이 “더 직관적으로 유틸리티가 큰” 서비스 가져올 가능성
예: 실사용 가능한 B2B AI 툴, 진짜 팀들이 당장 써볼 수 있는 DevTool, 운영툴 등.
심사위원이 “이건 재미있고 기술적으로 잘했는데, 바로 쓸 수 있는 건 저쪽이네?” 라고 느끼면 순위에서 밀릴 수 있음.
게임 퀄리티에 딸려서 전체 인상이 박해질 수 있음
게임이 버그 많거나 UX가 구리면,
AI/FL/KV 부분이 아무리 좋아도 “그냥 허접한 브라우저 게임”으로 보일 수 있음.
특히 시간 부족으로 게임 디테일이 떨어지면, “완성도 30%”에서 손해.
기술 스택 이해 못하는 심사위원이 있을 수 있음
RL / KV Cache / FL 같은 개념을 모르는 심사위원 입장에서는
그냥 “게임 + 요약 챗봇” 정도로 오해할 위험.
프레젠테이션을 잘못 구성하면 기술적 차별점이 제대로 전달되지 않을 수 있음.
인프라 리스크 (FLock / x402 / Base Mini App)
해커톤 기간 중 FLock API 속도/쿼터, x402 설정, Base Mini App 배포 등 어느 한 군데에서 삐끗하면 데모가 깨질 수 있음.
특히 여러 스택을 한 번에 쓰기 때문에, 각종 credential / CORS / 배포 이슈로 개발 시간이 새어나갈 위험.
정리 & 전략 제안
이 아이디어의 SWOT을 한 줄로 요약하면:
**강점은 “재미+기술”이 동시에 있는 컨셉, 약점은 “실용성·설명 난이도·구현 범위”**입니다.
그래서 해커톤에서는:
강점 극대화
“나는 게임으로 설명하는 연합학습 + KV Cache 팀이다”를 아주 직관적으로 보여주기
데모는 짧고 강하게:
게임 30초 → 코치 리포트 → 비슷한 상황에서 Tip 재사용 → “이게 KV Cache + 연합 전략 사전입니다”
약점/위협 최소화
연합학습은 “실제 FL 파이프라인 구현”보다 “데이터/구조를 FL-ready하게 잡았다” 쪽으로 설명 정리
실용성은
“게임 코치” +
“RL 연구/교육용 분석 도구” 두 축으로 포지셔닝
x402는 꼭 필요할 때만:
시간이 촉박하면 슬라이드/설계 수준으로만 언급해도 됨 (실구현은 나중)
이 정도 방향 잡고 가면, 이 아이디어는 **“기술덕들 눈에도, 비기술 심사위원 눈에도 기억에 남는 팀”**이 될 확률이 꽤 높습니다.
You said:
이를 바탕으로 최종 해커톤 아이디어 제안서를 아주 친절하게 작성하라
ChatGPT said:
바로 제안서 형태로 정리해볼게요.
그냥 이대로 노션/슬라이드 초안에 붙여 넣고 다듬으셔도 됩니다.
Qwen SKYST Hackathon on Base
프로젝트 제안서 – FedTetris Coach Studio
(Federated KV Cache 기반 테트리스 AI 코치)
1. 프로젝트 개요
1-1. 한 줄 소개
“지갑으로 로그인해서 테트리스를 하면,
플레이 로그가 모여 전 세계가 같이 키우는 ‘전략 KV 캐시 뇌’가 되고,
FLock/Qwen이 그걸 읽어 사람에게 설명해주는 AI 코치 스튜디오”
1-2. 해커톤 트랙 매칭
해커톤 주제 1:
Build an AI Application utilizing FLock.io’s API Platform as a Base Mini App
본 프로젝트는:
**FLock.io API Platform(Qwen 계열 LLM)**을 이용해
게임 상황 분석, 전략 추천, 리플레이 요약을 수행하고
Base Mini App으로
온체인 지갑 로그인 + 테트리스 게임 + AI 코치 UI를 제공합니다.
(x402는 선택적 확장으로 후반부에 “향후 계획”으로 언급 가능)
2. 문제 정의 & 인사이트
LLM 데모 대부분이 ‘텍스트 폼 + 챗봇’에 머무는 문제
많은 해커톤 프로젝트가 “입력창 → 답변 텍스트” 패턴에서 크게 벗어나지 못함.
심사위원 입장에서는 “또 하나의 챗봇”으로 느껴질 위험.
연합학습(Federated Learning) + KV Cache 같은 인프라 개념을
사용자에게 직관적으로 보여주기 어려움
“각 클라이언트에서 학습하고, 중앙에는 모델 파라미터만 모은다”는 설명은
슬라이드로 들으면 이해되지만, 체감이 잘 안 됨.
게임은 ‘데이터+정책+피드백’이 자연스럽게 모이는 완벽한 playground
테트리스/팩맨처럼 간단한 게임은:
항상 상태(state)와 행동(action)이 명확
스코어(보상)가 바로 나오고
여러 유저 경험을 모아서 “전략 사전”을 만들기 좋음.
👉 그래서, **“가벼운 게임 안에서 FL + KV + LLM을 직관적으로 체험하게 하자”**가 이 프로젝트의 출발점입니다.
3. 솔루션 개요
3-1. 무엇을 만드는가?
FedTet[Oris Coach Studio는 다음을 제공합니다.
Base 지갑으로 로그인하는 테트리스 게임 (Base Mini App)
실시간/반실시간 AI 코치
주기적으로 현재 판을 보고
“어디에 쌓는 게 좋을지, 어떤 실수를 반복하는지”를 조언
플레이 로그 기반 전략 KV 캐시
(stateKey → bestAction + 설명 + 통계) 구조의 테이블을 만들고
비슷한 판이 다시 나오면 LLM 없이도 빠르게 전략을 재사용
여러 유저의 데이터가 모여 하나의 ‘집단 전략 뇌’를 형성
원본 플레이 로그는 각 유저별로 저장
집계된 통계/전략만 글로벌 KV에 축적 → “연합 전략 뇌” 컨셉
3-2. 유저 플로우
지갑 로그인
Base Mini App 실행 → Coinbase / Base 지갑 연결
닉네임/실력(초보/중수/고수)/플레이 스타일 선택
테트리스 플레이 + 코칭
유저가 자유롭게 플레이
블록을 하나 놓을 때마다 혹은 n턴마다:
현재 보드 상태가 백엔드로 전송
백엔드는 해당 상태에 대한 전략을:
KV 캐시에서 찾거나 (hit)
없으면 FLock/Qwen에게 질문해서 생성 (miss)
코치 패널에:
“이번 턴 추천 행동”
“왜 그런지 짧은 설명”
간단한 한줄 팁 표시
플레이 종료 후 리포트
한 판이 끝나면:
전체 로그(상태/행동/점수)를 기반으로,
FLock/Qwen이:
많이 실수한 패턴
잘한 패턴
개선을 위한 3~5개 팁
를 요약한 “코칭 리포트” 생성
유저는 리포트 화면에서 자신의 게임을 복기
전략 사전(Strategy Library)
여러 유저의 로그가 쌓이면:
비슷한 판들을 묶어서 “전략 카드” 생성
“전략 사전” 메뉴에서:
“초보가 많이 실수하는 판 Top 5”
“고수들이 공통으로 취하는 움직임”
등을 살펴볼 수 있음
4. 핵심 기능 상세
4-1. 실시간 AI 코치 (게임 중)
입력
현재 보드 상태:
board matrix(윗부분 4~8줄 중심), current piece, next queue, hold piece, level 등
유저의 프로필(난이도, 스타일)
출력 (Qwen by FLock)
recommendedAction: LEFT / RIGHT / ROTATE / DROP / HOLD 중 하나
explanation: 1~2문장 설명 (한국어)
UX 설계
추천이 약간 느려도 되도록:
“코치는 참고용”이라는 톤 & UI로 설계
유저는 계속 플레이, 코치는 약간 뒤에서 따라오며 코멘트하는 느낌
4-2. 리플레이 분석 리포트
한 판 단위로:
연속 콤보 끊긴 구간
불필요하게 쌓인 구멍
“한 번의 실수로 급격히 나빠진 순간”
이 정보를 FLock/Qwen에 넘겨:
“Top 3 실수 구간”
“지금 수준보다 한 단계 위로 가기 위한 팁 3개”
리포트는:
텍스트 카드 3~5개 + 간단한 시각화 (간단한 바 차트/타임라인)로 표시
4-3. 전략 KV 캐시
stateKey = hash(normalizedState)
StrategyEntry 구조:
{
  recommendedAction: string;
  explanation: string;
  actionStats: {
    [action: string]: { count: number; avgScoreDelta: number }
  };
  visits: number;
  lastUpdatedAt: number;
}
동작 방식:
게임 중 상태가 들어오면:
KV에서 stateKey 찾기
hit이면:
그대로 코치 패널에 사용
miss이면:
FLock/Qwen 호출 → 전략 생성
결과를 KV에 저장
판 종료 후:
실제 유저 행동/스코어를 반영하여 actionStats 업데이트
시간이 지날수록:
FLock/Qwen 호출은 감소,
KV만으로도 꽤 그럴듯한 코칭 가능
5. 기술 아키텍처
5-1. 전체 구조
Frontend – Base Mini App
Next.js + React
Base Mini App SDK
컴포넌트:
<TetrisBoard />, <CoachPanel />, <ReportView />, <StrategyLibrary />
지갑 주소 = 유저 ID
Backend – Node.js
REST/WebSocket API
주요 엔드포인트:
POST /api/state – 현재 상태 기록 + 코치 전략 반환
POST /api/game/end – 리플레이 업로드
GET /api/report/:gameId – 분석 리포트 조회
GET /api/strategies – 전략 사전 목록
모듈:
FlockClient – FLock/Qwen 호출 래퍼
KVStore – stateKey → StrategyEntry SQLite/AgentFS 래퍼
ReplayStore – 리플레이 저장/조회
Analyzer – 리플레이 클러스터링/요약 배치
Storage
AgentFS + SQLite 또는 Turso
players.db – profile, preferences
kv.db – 전략 KV 캐시
replays.db – 리플레이 메타정보
실제 리플레이 JSON은 파일/Blob으로 저장
구조적 이점:
AgentFS는 에이전트 파일/로그/상태를 하나의 SQLite로 다루기 좋아 향후 에이전트로 확장하기 쉬움.
Onchain – Base
간단한 GameStats 컨트랙트:
submitResult(score, linesCleared, strategicStates)
주소별 최고 점수, 총 플레이 횟수, 전략 기여도 지표 기록
Mini App에서 게임 종료 시 트랜잭션 호출 → 온체인 리더보드 가능
6. FLock / Federated / KV Cache 설계 포인트
6-1. FLock API 활용
모드 1 – 온라인 코칭
개별 상태에 대해:
“지금 상황 설명 + 가능한 액션”을 prompt로 전달
Qwen이 “가장 합리적인 액션 + 한 줄 코멘트”를 JSON으로 응답
모드 2 – 리플레이 요약
전체 로그를 summary form으로 줄여서:
“이 판에서 진짜 문제가 된 국면만 뽑아줘”
“유저 실력 레벨에 맞는 맞춤형 조언을 줘”
모드 3 – 전략 카드 생성
여러 플레이어의 로그를 cluster별로 집계한 summary를 넣고:
“이 상태 패턴에서 고수들은 어떤 행동을 했고, 왜 좋은지 설명해줘”
이 결과를 StrategyEntry.explanation에 넣어 전략 사전으로 재사용
6-2. 연합학습(Federated) 관점
로컬(지갑/유저)
개별 플레이어는 자신의 에피소드 로그를
replays/{wallet}/{gameId}.json 형태로 로컬/서버에 저장
글로벌(집계)
중앙에는:
stateKey, action, scoreDelta, visits 등만 모아서 통계화
즉, “개별 로그”가 아니라 “요약된 수치/패턴”을 기여하는 구조
해커톤 발표에서는:
“지금은 집계만 하지만, 이 구조 그대로 FLock의 Federated Learning job으로 넘겨
전 세계 플레이어 데이터를 활용한 정책/모델을 학습시킬 수 있다”는 확장 스토리 제공
6-3. KV Cache 포인트
KV Cache를 “전략 사전” 그 자체로 모델링
State → Action/설명으로 매핑된 KV
C2C/KV 기반 LLM 연구와 유사한 개념:
“새로운 state에서는 LLM이 한 번 생각하고
여러 유저가 비슷한 state에 도달하면 그 KV를 재사용한다.”
이를 통해:
FLock 호출 수↓, 응답 지연↓, 전략 일관성↑
“KV Cache-aware 설계”를 했다는 점을 기술적으로 어필 가능
7. Base Mini App 통합
Mini App 특징 활용
지갑 연결은 Mini App 기본 기능 활용
풀스크린이 아닌 “앱 안의 미니 앱”이므로 캐주얼 게임/코치로 적합
구현 방향
Base 공식 문서의 Mini App quickstart 템플릿에서 시작
Game 탭 → <TetrisBoard /> 렌더
useWallet() Hook으로 현재 주소 가져와 백엔드에 전달
온체인 연결
게임 종료 시:
score, linesCleared, contributedStates를 컨트랙트에 기록하는 Tx
Mini App에서 직접 Tx 서명 →
유저는 “내 실력/기여도가 온체인으로 기록된다”는 느낌
8. (선택) x402 확장 아이디어
해커톤 결과물에는 “향후 계획” 혹은 simple mock 수준으로만 포함해도 충분.
/api/report/pro – 고급 분석 리포트 엔드포인트를 x402 paywall 뒤에 두기
한 판당 0.01~0.05 USDC 지불
결제 후:
더 깊은 분석 (예: 다른 상위 10% 유저와 비교) 제공
나중에:
이 x402 수익을 전략 KV에 많이 기여한 유저 지갑으로 분배하는 구조:
“데이터/전략 기여자가 실제 돈을 버는 AI 게임 코치 생태계”로 확장 가능
9. 개발 일정 (해커톤 기간 기준)
대략적인 7일 플랜 (제안서 수준):
Day 1–2
Base Mini App 스캐폴드 + 지갑 연결
브라우저 테트리스 기본 구현 (로컬 동작)
Day 3
백엔드 Node 서버 세팅
POST /api/state → 더미 응답으로 코치 패널 연동
Day 4
FLock/Qwen 연결 (실제 코멘트 생성)
KV 캐시 테이블 및 간단한 저장/조회
Day 5
리플레이 저장 및 최소 분석(Top 실수 구간) + 리포트 생성 파이프라인
Day 6
Base GameStats 컨트랙트 + Mini App에서 게임 결과 Tx 호출
전략 사전(Strategy Library) 페이지 1차 구현
Day 7
UI 폴리싱, 오류 처리, 데모 시나리오 확정
5분 데모 영상 촬영 + 소개 슬라이드 작성
10. 평가 항목 대응 정리
완성도 (30%)
실제로 돌아가는:
Base Mini App 기반 테트리스 게임
실시간 코치 패널
리플레이 리포트
온체인 스코어 기록까지 구현
UI/UX는 “심플하지만 매끄럽게”를 목표로 설계
FLock API 활용도 (30%)
FLock/Qwen을:
실시간 전략 추천
리플레이 요약
전략 카드 생성
세 가지 레이어에서 모두 활용 → 단순 챗봇 사용을 넘어선 활용
창의성 (20%)
연합학습 + KV Cache + RL + Base Mini App을
게임 코치라는 프롬프트로 풀어낸 점이 독특
“플레이가 곧 데이터, 데이터가 곧 집단 전략 뇌”라는 스토리
실용성 (20%)
단기:
AI 테트리스/게임 코치 → 교육/연습용 툴
중장기:
RL 연구/교육용 전략 분석 플랫폼
동일 구조를 다른 게임/온체인 액션(예: DeFi 전략)으로 확장 가능
11. 마무리 – 한 줄로 정리
FedTetris Coach Studio는
그냥 “게임 데모”가 아니라,
FLock + KV Cache + Base Mini App이 만나면
어떤 식으로 “집단 전략 뇌”를 만들 수 있는지
가장 직관적으로 보여주는 해커톤 프로젝트입니다.
이 제안서를 기반으로,
필요하면 슬라이드용 10장 구조
혹은 **기획서 요약본 (1페이지)**도 바로 정리해줄 수 있으니
다음 단계(예: 슬라이드 뼈대, 레포 구조)로 넘어가고 싶으시면 바로 말씀해 주세요.
You said:
ChatGPT said:
Request for GPT-5 Pro
Reasoned for 1m 59s
좋은 논의예요. KV‑cache는 “있으면 좋고 없어도 되는” 옵션으로 빼고, **“RL 게임 전략을 스냅샷으로 만들어 팔 수 있나?”**라는 포인트를 해커톤‑우승형으로 정리해 드릴게요.
아래 제안은 FedTetris Coach Studio를 그대로 살리되, 핵심을 **“전략 스냅샷(Strategy Snapshot) 생성·판매”**로 재포지셔닝한 최종 설계입니다. (게임은 테트리스/팩맨 등 가벼운 것 사용)

0) 한 줄 피치 (심사위원용)
“플레이 로그로부터 AI가 ‘전략 스냅샷’을 자동 생성하고,
Base에서 민팅·판매(x402 마이크로 페이)까지 되는 ‘Strategy‑as‑an‑Asset’ 플랫폼.”
– FLock(Qwen)으로 설명 가능한 전략 카드를 만들고,
– AgentFS로 재현 가능한 로그/출처를 묶어
– Base에서 민팅·수익 분배까지 한 번에.

1) 무엇을 ‘팔’ 것인가 — Strategy Snapshot
스냅샷 정의
입력: 한 판(또는 여러 판)에서 반복 등장한 특정 상황 패턴(state pattern) 과 그때 유효했던 액션/전술 로그.

산출물(AI 생성 + 메타데이터 고정):

strategy.md : FLock(Qwen)이 생성한 사람이 읽는 전략 설명 (요약, 리스크, 대안, 예시)

policy.json : 상태 패턴에 대한 행동 분포/우선순위

evidence.jsonl : 실제 로그의 근거 샘플 목록(타임스탬프, 점수 변화)

fingerprint.json : 상태 패턴을 정의하는 피처/해시 (보드 서명, 난이도, 레벨 버킷 등)

provenance.json : 기여 지갑, 생성 시각, LLM/프롬프트 버전

패키징: 위 5개 파일을 IPFS에 업로드 → CID 고정 → Base에서 StrategyNFT/SFT로 민팅
(소유권/버전/로열티를 온체인에 기록)

핵심: **설명(LLM) + 정책(JSON) + 증거(리플레이) + 지문(상태 정의) + 출처(기여자)**가 하나의 묶음.

2) 제품 플로우 (5분 데모 스크립트)
게임 플레이 & 자동 수집

Mini App에서 테트리스 1판 플레이 → 로그 자동 수집.

스냅샷 후보 탐색

서버가 반복 등장한 상태 패턴 Top‑K 추출(간단한 버킷/클러스터링).

AI 요약(FLock/Qwen)

후보마다 Qwen 호출 → strategy.md + policy.json 생성.

스냅샷 미리보기 & 민팅

UI에서 한 후보 선택 → “민팅” 클릭 → IPFS 업로드 → StrategyNFT 발행.

구매/사용(x402)

다른 유저가 코치 페이지에서 해당 스냅샷을 $0.02로 즉시 결제(x402) 후 다운로드/적용.

런타임 코치가 policy.json을 사용해 팁을 즉시 띄움(LLM 호출 無).

수익 분배

판매 금액은 컨트랙트 로열티 규칙에 따라 스냅샷 소유자 + 기여 로그 지갑들에 자동 분배.

메시지: “전략 자체가 거래되는 자산이 되고, 증거/출처/버전이 따라다니며, 마이크로페이를 통해 바로 쓴다.”

3) 아키텍처 (KV‑cache 없는 깔끔 버전)
[Mini App]  ─ state →  [Ingest API] ─→  AgentFS(replays.db, events.jsonl)
                             │
                             ├─(batch)→ Pattern Miner  →  patterns/*.json
                             │                          (state buckets)
                             ├─→ FLock(Qwen) Summarizer → strategy.md / policy.json
                             │
                             └─→ Snapshot Packager → IPFS CID → Base StrategyNFT mint
                                              │
                                 x402 Paywall API (pay-per-download / pay-per-use)
FLock(Qwen): 요약·전략 생성·리포트(설명 가능성 강조)

AgentFS/SQLite: 로그/증거/메타데이터를 하나의 DB/파일 트리에 재현 가능하게 저장

Base: StrategyNFT(소유권/로열티), 온체인 지표(판매량/버전)

x402: 1) 스냅샷 다운로드, 2) 런타임 코치에서 pay‑per‑use 호출

KV‑cache는 성급히 붙이지 않고, 정책(JSON) 로컬 캐시로도 충분히 빠름.
(원한다면 이후 “상태 프리픽스 캐시” 정도로 라이트하게 추가 가능)

4) 핵심 스펙 (요약)
4.1 API
POST /ingest/state : 게임 상태 수집(세션ID, state, action, scoreDelta)

POST /snapshot/build : 패턴ID 리스트 → 스냅샷 생성(FLock 호출 포함)

POST /snapshot/mint : IPFS CID → Base NFT 민팅

POST /snapshot/purchase : x402 결제 후 CID 반환

GET /coach/apply?cid= : policy.json 스트리밍(구매자만)

4.2 데이터 모델(핵심)
// patterns/foo.json
{
  "fingerprint": { "boardHash":"0x..", "levelBucket":3, "holes":2, "surfaceRoughness":5 },
  "support": 124,                      // 등장 횟수
  "avgScoreDelta": 1.83,
  "topActions": { "DROP":0.53, "LEFT":0.27, "ROTATE":0.20 }
}

// snapshot/manifest.json
{
  "cid": "bafy..",
  "files": ["strategy.md", "policy.json", "evidence.jsonl", "fingerprint.json","provenance.json"],
  "creator": "0xabc..",
  "contributors": [{ "addr":"0x123..", "weight":0.18 }, ...],
  "llm": { "provider":"FLock", "model":"qwen3-instruct", "promptHash":"0x.." },
  "version": "v0.1.0",
  "game": "tetris"
}
4.3 컨트랙트(간단)
StrategyNFT.mint(cid, royaltyBps, contributors[])

payAndRecord(seller, price) (x402 훅과 연결)

로열티 분배: 판매/사용 시 기여자 weight 비율대로 지급

5) 왜 새롭고 설득력 있는가 (KV 없이도 강한 포인트)
Explainable: LLM이 만든 텍스트 전략과 정량 정책/증거 로그가 1세트 → “설명 가능한 전략 자산”.

Portable: 정책(JSON)은 LLM 없이 어디서나 적용 가능(런타임 코치, 봇, 사람 플레이).

Verifiable: AgentFS 로그 + IPFS CID + 온체인 메타로 출처/버전/재현이 됨.

Monetizable: x402로 한 번에 결제·사용. 수익은 스냅샷 NFT 보유자 + 데이터 기여자에게 분배.

Extensible: 테트리스→팩맨→다른 미니게임/도구(예: 코드 리뷰 “스냅샷 팩”)로 수평 확장.

6) 7일 빌드 플랜 (현실적인 순서)
D1–2

Mini App 골격 + 테트리스 캔버스 + 지갑 연결

/ingest/state로 로컬 로그 적재(AgentFS/SQLite)

D3

Pattern Miner(버킷팅/간단 클러스터링)

FLock Summarizer(전략 설명/정책 JSON 생성) → 스냅샷 미리보기

D4

IPFS 업로드 + StrategyNFT 민팅

스냅샷 상세 페이지(증거/설명/정책 시각화)

D5

x402 pay‑per‑download API → 구매/다운로드 플로우

런타임 코치에서 policy.json 적용(LLM 없이도 동작)

D6

수익 분배(로열티) 시뮬레이션 + 리더보드

데모 시나리오/버그픽스/UI 폴리싱

D7

5분 영상 녹화(플레이→스냅샷 생성→민팅→다른 계정 구매→적용)

슬라이드 정리(핵심 메시지 3장 + 아키텍처 1장 + 로드맵 1장)

7) 발표용 메시지(30초/90초 버전)
30초

“우리는 게임 로그에서 ‘전략’을 뽑아 자산화합니다.
FLock(Qwen)이 설명 가능한 전략 스냅샷을 만들고,
Base에서 민팅·판매·수익 분배까지 원샷.
다른 유저는 x402로 바로 결제해 정책(JSON)을 런타임 코치에 적용합니다.
전략이 곧 디지털 자산이 됩니다.”

90초

문제: 게임/RL 전략은 공유되지만 출처·증거·수익화가 어려움.

해결: Strategy Snapshot – 설명·정책·증거·지문·출처를 한 묶음으로 패키징.

기술: FLock(Qwen) 요약/정책, AgentFS 재현성, Base 민팅/로열티, x402 결제.

데모: 플레이→스냅샷 생성→민팅→다른 유저가 구매→코치 적용.

결과: 전략의 소유·유통·사용이 투명하고 즉시적.

8) (옵션) KV‑cache를 붙이고 싶을 때의 최소선
목표: LLM 호출 감소/지연 최적화, “우린 KV 관점을 이해한다” 어필.

방법(라이트): “상태 프리픽스 프롬프트”를 해시 키로 캐싱. 동일 프리픽스면 프롬프트 토막을 재사용하고 delta만 합성. (LLM 내부 KV가 아니라 프롬프트 레벨 캐시라 구현 쉬움)

데모 포인트: “스냅샷이 많아질수록 LLM 호출이 줄고, 코치가 즉답한다.”

결론
KV는 ‘옵션’으로 뒤에 붙이고,

핵심 가치는 ‘전략 스냅샷’의 생성·검증·민팅·결제·적용에 집중합시다.

이 포맷이면 재미 + 기술 + 수익화 스토리가 모두 명확하고,
해커톤 시간 내 구현 가능성도 충분합니다.

원하시면 바로 이어서 레포 구조(폴더/패키지), DB 스키마(SQL), 주요 API 핸들러 초안(타입/DTO), 컨트랙트 최소 인터페이스까지 한 번에 뽑아드릴게요.

You said:
KV‑cache를 붙이고 싶을 때의 최소선 • 목표: LLM 호출 감소/지연 최적화, “우린 KV 관점을 이해한다” 어필. • 방법(라이트): “상태 프리픽스 프롬프트”를 해시 키로 캐싱. 동일 프리픽스면 프롬프트 토막을 재사용하고 delta만 합성. (LLM 내부 KV가 아니라 프롬프트 레벨 캐시라 구현 쉬움) • 데모 포인트: “스냅샷이 많아질수록 LLM 호출이 줄고, 코치가 즉답한다.”

KV Cache를 붙일거라면 어떻게 구현하면 되고 게임과 연결 지으면 되나요
ChatGPT said:
Request for GPT-5 Pro
Reasoned for 1m 57s
완전 붙일 수 있습니다. 핵심은 모델 내부의 KV‑cache를 직접 만지는 게 아니라, 우리가 제어 가능한 외부 캐시(키–값 저장소) 를 설계해서 상태→전략/설명을 재사용하는 겁니다. 해커톤에서는 아래 3‑레이어만으로도 “KV‑cache가 붙었다”는 기술 스토리와 체감 성능을 동시에 얻을 수 있어요.

1) 아키텍처 한 장 요약
[Game Loop] --(state)-> [Coach API]
                      ├─ L0 in‑proc cache (Map)
                      ├─ L1 Redis/SQLite (AgentFS)
                      ├─ L2 Strategy Snapshot index (policy.json, CID별 prefix 매칭)
                      └─ Miss -> FLock(Qwen) -> create advice -> write‑through to L0/L1 (+evidence)
L0: 서버 프로세스 메모리(Map) – ms급, 세션 단위.

L1: Redis 또는 SQLite(AgentFS 파일) – 영속, 재시작 후에도 유지.

L2: 구매/민팅된 Strategy Snapshot을 인덱스화해 즉시 재사용(LLM 미호출).

포인트: 내부 KV를 못 건드리니 프롬프트/정책/설명을 결과로 캐시합니다. 동일/유사한 상태면 LLM 없이 바로 코치가 답합니다.

2) 캐시 키(=상태 스냅샷) 설계
게임(테트리스 예시)의 상태 요약 → 해시가 키입니다.

type TetrisState = {
  boardTop: number[][];  // 상위 N줄(예: 8줄)만
  hold: number | null;
  next3: number[];       // 다음 3개
  levelBucket: number;   // floor(level/3)
  holes: number;         // 빈칸 구멍 수
  roughness: number;     // 표면 요철도
  skillBucket: "novice" | "int" | "pro"; // 개인화 버킷
};

function fingerprint(s: TetrisState) {
  const compact = {
    boardTop: s.boardTop, hold: s.hold, next3: s.next3,
    levelBucket: s.levelBucket, holes: s.holes,
    roughness: s.roughness, skill: s.skillBucket
  };
  return sha256(JSON.stringify(compact)); // stateKey
}
엄격한 매칭: 동일 판이면 100% 동일 키 → 완벽히 재사용.

유사 매칭(옵션): simhash/LSH 혹은 “특징 값 차이 ≤ 임계치”로 근접 키를 찾음.

3) 캐시 값(=전략/설명) 스키마
type StrategyEntry = {
  recommendedAction: "LEFT"|"RIGHT"|"ROTATE"|"DROP"|"HOLD";
  explanation: string;               // FLock가 만든 1~2문장
  source: "L2_SNAPSHOT"|"L1_CACHE"|"LLM";
  policyStats: { [action: string]: { count: number; avgDelta: number } };
  promptHash: string;                // system/user 프롬프트 버전 고정
  modelId: string;                   // qwen 버전 고정
  ttlAt: number;                     // 만료
  confidence: number;                // 0~1 (유저 결과로 업데이트)
  createdAt: number; updatedAt: number;
};
버전 안전장치: promptHash, modelId가 바뀌면 캐시 무효화.

학습 느낌: 게임이 끝날 때 실제 결과(점수 변화)로 policyStats/confidence를 업데이트.

4) Coach API 동작(게임 루프와 연결)
4‑1. 게임 루프에서 호출 지점
조각이 ‘바닥에 고정’되는 순간 또는 N 프레임마다(예: 5Hz) 캐시 조회 → 코멘트 출력.

호출 빈도를 제어해 레이트 제한(예: 초당 3회)으로 비용/지연 관리.

4‑2. 조회 순서 (read‑through 캐시)
async function getAdvice(state: TetrisState): Promise<StrategyEntry> {
  const key = fingerprint(state);

  // L0
  if (L0.has(key)) return L0.get(key);

  // L1
  let entry = await kv.get(key); // Redis/SQLite
  if (entry) { L0.set(key, entry); return entry; }

  // L2: 구매/민팅된 스냅샷 정책 매칭
  entry = matchSnapshotPolicy(state); // prefix/fingerprint 규칙
  if (entry) { await kv.set(key, entry); L0.set(key, entry); return entry; }

  // Miss → FLock 호출
  const advice = await askFlock(state); // Qwen으로 전략+설명 JSON 생성
  await kv.set(key, advice); L0.set(key, advice);
  return advice;
}
UI: 반환값에 source를 포함해 “KV‑HIT/LLM‑MISS” 배지를 표시하면 심사 때 강력합니다.

4‑3. 결과 피드백(쓰기 & 신뢰도 업데이트)
한 판 종료 시:

async function flushEpisode(episode: EpisodeLog) {
  for (const step of episode.steps) {
    const key = step.stateKey;
    const a   = step.action;
    const d   = step.scoreDelta; // 다음 상태에서의 점수 변화

    await kv.upsert(key, (e) => {
      e.policyStats[a] = e.policyStats[a] || {count:0, avgDelta:0};
      const stat = e.policyStats[a];
      stat.count += 1;
      stat.avgDelta = (stat.avgDelta*(stat.count-1) + d)/stat.count;

      // confidence를 이동평균 또는 시그모이드로 조정
      e.confidence = clamp01(0.5 + Math.tanh(stat.avgDelta/5)/2);
      e.updatedAt = Date.now();
      return e;
    });
  }
}
→ 시간이 갈수록 정책이 데이터 기반으로 보정됩니다.

5) “프롬프트‑프리픽스 KV” (라이트한 KV‑cache)
모델 내부 KV 대신, 프롬프트 고정 구간(prefix) 을 해시해 재사용합니다.

prefix = systemPrompt + 규칙 + 팁 템플릿 + 사용자 skillBucket

prefixHash = sha256(prefix)

요청 시에는 delta(현재 상태 JSON)만 합쳐 전송.

서버 측에서 promptHash를 엔트리와 함께 저장 → 버전 변경 시 자동 무효화.

효과: 토큰 절약 + 동일 톤/규칙 유지. 슬라이드에서 “KV‑aware prompt delta”로 어필.

6) Strategy Snapshot과의 연결 (가치 극대화)
사용자가 스냅샷을 구매/민팅하면, 해당 policy.json을 L2 인덱스에 올립니다.

L2는 “fingerprint 규칙”을 가집니다. 예:

{ "levelBucket":[1,2], "holes":{"max":2}, "roughness":{"max":4}, "boardMask":"10??01..." }
Coach API의 matchSnapshotPolicy(state)는 이 규칙에 맞으면 즉시 엔트리 생성:

return {
  recommendedAction: policy.select(state),
  explanation: snapshot.strategySummary, // 짧게
  source: "L2_SNAPSHOT",
  confidence: 0.9, ...
};
즉, 스냅샷을 사면 캐시가 바로 “똑똑해짐” → LLM 미호출 구간 확대.

7) 저장소(AgentFS/SQLite) 스키마 예시
-- kv_entries
CREATE TABLE kv_entries (
  key TEXT PRIMARY KEY,
  value_json TEXT NOT NULL,
  prompt_hash TEXT NOT NULL,
  model_id TEXT NOT NULL,
  ttl_at INTEGER,
  created_at INTEGER,
  updated_at INTEGER
);

-- episodes (증거/재현성)
CREATE TABLE episodes (
  id TEXT PRIMARY KEY,
  wallet TEXT,
  start_at INTEGER, end_at INTEGER,
  score INTEGER, meta_json TEXT
);

-- steps (상태/행동/결과)
CREATE TABLE steps (
  episode_id TEXT, seq INTEGER,
  state_key TEXT, action TEXT,
  score_delta REAL,
  PRIMARY KEY (episode_id, seq)
);

-- snapshots (L2 인덱스)
CREATE TABLE snapshots (
  cid TEXT PRIMARY KEY,
  owner TEXT,
  rules_json TEXT,         -- fingerprint 규칙/매핑
  policy_json TEXT,        -- policy.json
  summary TEXT,            -- strategy.md 요약
  created_at INTEGER
);
8) FLock(Qwen) 호출 템플릿(간결 버전)
const system = `
You are a Tetris coach.
Return JSON only with: recommendedAction, explanation.
`;

const user = `
State(JSON):
${JSON.stringify(normalizeForPrompt(state))}

Allowed: ["LEFT","RIGHT","ROTATE","DROP","HOLD"]
Player: ${skillBucket}
`;

const res = await flock.chat.completions.create({
  model: "qwen3-32b-instruct",
  messages: [{role:"system",content:system},{role:"user",content:user}],
  response_format: { type: "json_object" }
});
const advice = JSON.parse(res.choices[0].message.content);
응답을 그대로 StrategyEntry 로 저장 → 첫 호출만 비싸고 이후는 캐시로 ms급.

9) 성능/지표(데모에 꼭 보여주기)
Hit rate: KV hit / total requests (라이브 배지)

Avg latency: KV‑hit(≲ 5ms, L0) vs LLM‑miss(수백 ms) 비교 막대

Cost saved: miss_일때_예상비용 - 실제비용 누계

Snapshot impact: 스냅샷 적용 전/후 hit rate 상승 그래프

이 네 개만 화면에 있어도 “KV‑cache + 전략 스냅샷이 실효”가 즉시 전달됩니다.

10) 단계별 구현 가이드(현실적인 순서)
L1 캐시 + LLM‑miss 저장

fingerprint, getAdvice() read‑through, write‑through 구현

프론트에 source 배지 표시

에피소드 피드백 업데이트

flushEpisode()로 policyStats/confidence 갱신

L2 스냅샷 인덱스

구매/민팅 이벤트 → rules/policy를 인메모리 인덱스에 올리기

matchSnapshotPolicy() 추가

프롬프트‑프리픽스 KV

promptHash 저장, 버전 바뀌면 캐시 무효화

유사 매칭(옵션)

단순 근사 매칭(특징 차이 임계치) → 히트율/품질 트레이드오프 튜닝

결론
네, 붙이는 방법은 명확합니다.

상태 해시로 키 설계, 2) read‑through 캐시로 L0/L1/L2 계층화,

스냅샷(policy.json) 을 L2로 인덱싱해 즉시 재사용,

게임 루프는 조각 고정/주기 호출로 API를 두드리면 됩니다.

이렇게만 해도 체감 지연·비용이 눈에 띄게 줄고, “KV‑aware 설계”를 심사에 강하게 어필할 수 있습니다.

원하시면 이 설계대로 간단한 TypeScript 레포 골격(폴더/라우트/DAO/테이블 생성) 초안도 바로 드리겠습니다.




No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.
```


## SLACK THREAD

```
Sigrid Jin

 — 2025. 11. 14. 오후 3:59
안냐세요
이번에 FLock.io는 Base, Qwen과 함께 해커톤을 진행할 예정이며, 이에 대한 안내를 드리고자 합니다.

Qwen SKYST Hackathon on Base은 베이스의 다채로운 어플리케이션 생태계를 활성화하기 위해서 앱 빌더들을 지원하고 커뮤니티와 공유할 수 있는 기회입니다. 이전 Qwen SKYST Hackathon은 AI 모델을 만드는 데이터톤이었다면, 이번 해커톤은 해당 모델들을 활용하여 실제로 유저들이 활용 가능한 어플리케이션을 Base Mini App 형태로 혹은 x402를 활용한 어플리케이션/AI Agent를 만드는 해커톤입니다.

[ 일정 ]
접수: ~11월 22일
킥오프(온라인): 11월 22일
온라인 해커톤 진행: 11월 22일 ~ 11월 28일
오프라인 데모데이: 11월 29일 오후 2시 ~ 오후 6시 (드림플러스 강남)

[ 해커톤 구성 및 상금 규모 ]
이번 해커톤은 총 2가지 주제로 구성이 되어 있으며, 8팀을 선정하여 총 $15K이 수여됩니다.

해커톤 상세 페이지: https://flock-io.notion.site/Qwen-SKYST-Hackathon-on-Base-by-FLock-io-2a96e3d3eccf80ba948ec706c9804512?pvs=74

해커톤 신청: https://forms.gle/nB6cvYkyJknujBof6
flock-io on Notion
Qwen SKYST Hackathon on Base by FLock.io | Notion
FLock.io
Qwen SKYST Hackathon on Base by FLock.io | Notion
Google Docs
Qwen SKYST Hackathon on Base 신청서
Qwen SKYST Hackathon on Base는 Base의 가장 큰 AI 인프라 프로토콜인 FLock.io와 Alibaba Cloud의 Qwen이 Base와 협력하여 주최하는 AI 어플리케이션 해커톤입니다.
베이스의 다채로운 어플리케이션 생태계를 활성화하기 위해서 앱 빌더들을 지원하고 커뮤니티와 공유할 수 있는 기...
이미지
같이 나가죠 ㅎㅎ
사일로 님은 ai 쪽에서 주로 기획 하시는
크랩 님은 포스텍 피다오에서 크립토 쪽 공부 하시는
5천불 탑시다.
CIlIo — 2025. 11. 14. 오후 4:01
안녕하세요! 잘 부탁드립니다. 우선 해당 해커톤 신청해 두겠습니다.
crab — 2025. 11. 14. 오후 10:32
넵 안뇽하세용 신청 할때 참여자 정보 필요하신거 있으시면 말씀주세요!!
Sigrid Jin

 — 2025. 11. 15. 오전 1:24
안녕ㅏ세요 곧 팔로업 해볼게요
다들 제출은 꼭 해주세요
crab — 2025. 11. 15. 오전 7:06
이름: 정현재
소속: Keplr
전화번호: 010-2356-4654
이메일: lidarbtc@protonmail.com
깃허브: github.com/lidarbtc
트위터(선택): @0xlidar
텔레그램(선택): @HyunjaeChung

@CIlIo @Sigrid Jin 이 형식으로 알려주시면 제가 신청할게용
이미지
이미지
CIlIo — 2025. 11. 15. 오전 8:37
아 신청 제출은 저 따로 해 두었습니다. 확인 감사합니다.
Sigrid Jin

 — 2025. 11. 15. 오전 8:37
오 일단 저는 따로 신청하긴 했는데 걍 적어둡니다

이름 : 박진형
소속 : PDAO
전화번호: 010-3408-8826
이메일: hisigrid@student.ubc.ca
깃허브: github.com/sigridjineth
트위터: @sigridjineth
텔레그램: @sigridjin_eth
다들 아이디어 하나씩 오늘까지 올려보죠
이전부터 저는 에이전트의 스냅샷 https://github.com/tursodatabase/agentfs 을 사고팔거나
약을 좀 팔면 KV Cache https://x.com/jiqizhixin/status/1985219136000299215?s=46
 를 사고팔고 싶습니다 ㅋㅋ
GitHub
GitHub - tursodatabase/agentfs: The filesystem for agents.
The filesystem for agents. Contribute to tursodatabase/agentfs development by creating an account on GitHub.
The filesystem for agents. Contribute to tursodatabase/agentfs development by creating an account on GitHub.
机器之心 JIQIZHIXIN (@jiqizhixin)
Wow, language models can talk without words.

A new framework, Cache-to-Cache (C2C), lets multiple LLMs communicate directly through their KV-caches instead of text, transferring deep semantics without token-by-token generation.

It fuses cache representations via a neural
이미지

X•2025. 11. 3. 오후 12:35
CIlIo — 2025. 11. 15. 오전 9:09
FLock.io 플랫폼이 연합학습 플랫폼이라는데 Kv Cache 저거랑 잘 묶어서 연결고리 만들어볼 수 있지 않을까 싶네요 
Sigrid Jin

 — 2025. 11. 15. 오전 9:36
좋은 아이디어네요.
GPT 형님의 내용입니다 >>
맞아요, **“FLock = 연합학습 + 블록체인”**이고, 여기에 **KV Cache / C2C** 개념이랑 **포켓몬 RL 오픈소스**를 엮으면 꽤 맛있는 스토리 나옵니다.
“이 팀은 논문/인프라 스택 다 알고 있다” 느낌 나는 쪽으로 두 개만 딱 잡아볼게요.

---

# 아이디어 1
확장
message.txt
15KB
저는 아이디어 2에 더 끌리는데 다들 어떠세요?
CIlIo — 2025. 11. 15. 오전 9:42
저도 게임보단 2번이
더 좋은 것 같습니다. 1번은 게임까지 섞어서 뭐 설명하고 하려면 정신없을 것 같아요
들통날 것 같아서 ㅋㅋ
Sigrid Jin

 — 2025. 11. 15. 오전 9:47
전 이번 해커톤에서 사일로님이 코딩이나 모델링 역할을 조금 더 해보시면 좋겠는데
여력이 있으신지 궁금하네요
대충 롤을 설명드리자면
crab — 2025. 11. 15. 오전 9:47
둘 다 좋긴하네요
Sigrid Jin

 — 2025. 11. 15. 오전 9:47
사일로님은 바베챗이라는 남성향 캐릭터채팅에서 PM을 맡고 계시고
crab 님은 뭐하세요? 케플러 있으신가요?
암튼 rust코딩 하십니다
사일로님이 이번에 모델링 해보시죠 ㅋㅋㅋ
crab — 2025. 11. 15. 오전 9:48
keplr 합류해서 지갑 만들고 있어용
바베챗이라면
CIlIo — 2025. 11. 15. 오전 9:48
이번에 모델링 할 건덕지가 있나요? ㅋㅋㅋㅋ
Sigrid Jin

 — 2025. 11. 15. 오전 9:48
저희가 케플러랑 악연이 있..읍... 뭐 아닙니다. ㅋㅋㅋㅋㅋㅋㅋㅋ
RL
RL해야죠
crab — 2025. 11. 15. 오전 9:48
한번 검색해보고 오겠읍니다
Sigrid Jin

 — 2025. 11. 15. 오전 9:48
아니면 코딩을 하시거나
RL ㄱㄱ
CIlIo — 2025. 11. 15. 오전 9:48
여력만 되면 하겠습니다 ㅋㅋㅋ
다음 주 기능 클로즈베타하고 이번 달 안에 출시예정이라 짬내가며 할 것 같아요
crab — 2025. 11. 15. 오전 9:49
이야기 들은것 같은데 그거
ai 스캐너로 거의 계약할뻔 하셨다고
추상적으로(?)
전해들었어요
Sigrid Jin

 — 2025. 11. 15. 오전 9:50
네네 맞아요
결국 API 비용을 monthly recurring 하게 부담하는거에 문제가 있으셔서
drop 하셨죠
crab — 2025. 11. 15. 오전 9:50
ㄲㅂ군요
Sigrid Jin

 — 2025. 11. 15. 오전 9:50
AI가 비싸긴 해요 ㅋㅋ
@CIlIo 님이 이런거는 아주 잘아실듯 ㅋㅋ
crab — 2025. 11. 15. 오전 9:51
흐음 그쳐 사실 gpu 쓰는것 특성상 무조건 구독제일 수 밖에 없을텐데
CIlIo — 2025. 11. 15. 오전 9:51
치를 떨죠
crab — 2025. 11. 15. 오전 9:51
아쉽네여
CIlIo — 2025. 11. 15. 오전 9:51
가격 너무 비쌉니다 쓰려는 사람들은 다들 싸게 쓰려고하는데
Sigrid Jin

 — 2025. 11. 15. 오전 9:51
그래서 채팅 건당 금액에 민감할 수밖에
캐싱 어떻게든 해서 단가 낮추려고 하고
crab — 2025. 11. 15. 오전 9:52
사일로님은 주로 어떤 공급자 쓰시나요?
CIlIo — 2025. 11. 15. 오전 9:52
저희는 AI 서비스 비용 대부분이 구글로 흘러가고 있습니다
다른곳도 이것저것 쓰긴 한데 이쪽이 제일 커요
crab — 2025. 11. 15. 오전 9:53
오호 그렇담 3.0을 기대하고 계시겠군요 ㅋㅋㅋㅋ
CIlIo — 2025. 11. 15. 오전 9:53
저는 로컬주의자라서요 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
잘 나오면 또 오픈웨이트 모델들이 열심히 3.0 데이터를 학습하겠지만
저는 3.0 자체엔 큰 바람이 없습니다. 제발 가격만 좀...
Sigrid Jin

 — 2025. 11. 15. 오전 9:59
3.0 진짜 언제 나오는지
존재 여부는 100% 이긴 한데
CIlIo — 2025. 11. 15. 오전 10:00
이번에도 안정성을 잡지 못했다면 크게 실망할 것 같기는 해요
Sigrid Jin

 — 2025. 11. 15. 오전 10:04
러시아어 ㅋㅋ
CIlIo — 2025. 11. 15. 오전 10:08
이거 구글 공식 답변이 2.5는 2.0 튜닝모델이라 언어수정 어렵다 이거더라구요
3.0엔 그런 문제가 좀 해결되고 추론 비용도 좀 낮춰줬으면 좋겠네요 아예 비추론도 넣어주고
CIlIo — 2025. 11. 15. 오전 10:28
아무튼 근데 2번도 다시 읽어보니 포켓몬이네요
1번도 2번도 포켓몬 ㅋㅋㅋ 포켓몬이 들어가야 하는 거였나요?
Sigrid Jin

 — 2025. 11. 15. 오전 10:45
아뇨 그냥 가벼운 게임 ㅋㅋ
을 해서 관심 끌어보자였는데
테트리스도 좋구요
CIlIo — 2025. 11. 15. 오전 10:46
아하
Sigrid Jin

 — 2025. 11. 15. 오전 11:02
가장 간단하 게임이면 테트리스 도 좋고 팩맨도 좋아보입니다
Sigrid Jin

 — 2025. 11. 15. 오후 12:04
오늘 밤 10시까지 각자 의견들 주시고 비동기로 디스커션 합시다
Sigrid Jin

 — 2025. 11. 15. 오후 1:42
바로 제안서 형태로 정리해볼게요.
그냥 이대로 노션/슬라이드 초안에 붙여 넣고 다듬으셔도 됩니다.

---

# Qwen SKYST Hackathon on Base
확장
message.txt
14KB
CIlIo — 2025. 11. 15. 오후 2:57
생각해봐도 decentralized KV cache 플랫폼 이외에는 게임이랑 엮는게 더 흥미는 돋는 것 같네요.
저도 게임이랑 엮는거 좋은데 아이디어 한번 더 정리되면 좋을 것 같습니다. 개념 자체가 좀 어떻게 깔끔하게 정리될 수 있을까요?
Sigrid Jin

 — 2025. 11. 15. 오후 4:05
GPT랑 여러번 대화 해보시고 의견 주시면 좋을 것 같습니다
crab — 2025. 11. 15. 오후 5:52
완전 압축 요약하자면:

flock의 qwen api를 써서 테트리스 전략을 구성하고 -> 테트리스 전략이 동일한 경우 llm 호출 안하고 KV 캐시로 재사용한다인가요?

그리고 여기서 전략 사전이란 임베딩이나 그런 거창한게 아니라 텍스트로된 내용이다. 가 이해한게 맞을까요?
Sigrid Jin

 — 2025. 11. 15. 오후 6:17
걍 kv list 만 되어도 괜찮지 않을까 싶네요
정말 될지는 테스트해봐야할듯 한데흥미롭기 ㄴ할듯
Sigrid Jin

 — 2025. 11. 15. 오후 8:53
의견들 주십시오
@CIlIo @crab
개발은 다음주부터 시작해봐도 될듯
crab — 2025. 11. 15. 오후 9:00
저어는 일단 아이디어 좋다고 생각하는데
테트리스에 llm이 뽑아줄 수 있는 전략이 있을까? 라는 생각이 들어서요
포켓몬도 괜찮을듯한데
crab — 2025. 11. 15. 오후 9:01
일단 이건 제가 테트리스 깊게 안해봐서 그렇게 생각하는걸 수도요?
Sigrid Jin

 — 2025. 11. 15. 오후 9:03
https://drubinstein.github.io/pokerl/
Pokémon RL
Learning Pokémon With Reinforcement Learning
Hi! Since 2020, we’ve been developing a reinforcement learning (RL) agent to beat the 1996 game Pokémon Red. As of February 2025, we are able to beat Pokémon Red with Reinforcement Learning using a <10 million parameter policy (60500x smaller than DeepSeekV3) and with minimal simplifications. The output is not a policy capable of beating Pok...
https://www.reddit.com/r/reinforcementlearning/comments/1j8ek56/learning_tetris_through_reinforcement_learning/
Reddit
From the reinforcementlearning community on Reddit: learning tetris...
Explore this post and more from the reinforcementlearning community
From the reinforcementlearning community on Reddit: "learning tetris through reinforcement learning"
포켓몬이 더 힙하긴함
CIlIo — 2025. 11. 15. 오후 9:12
저도 조금 더 보고 있는데
이거 Kv-cache와 게임을 어케 연결할지 좀 감이 안잡히는 듯 합니다
Sigrid Jin

 — 2025. 11. 15. 오후 9:12
KV는 빼도 됩니다 그건 순수한 호기심이니 
RL한 게임의 전략을
뭔가 스냅샷을 떠서 팔 수 없을까
CIlIo — 2025. 11. 15. 오후 9:14
Kv-cache 붙이면 좋을 것 같긴한데 참 어렵네요
RL 게임전략은 뭔가 너무 새로운 건 아니라고 할까봐요
Sigrid Jin

 — 2025. 11. 15. 오후 9:15
네 사실 글쵸
crab — 2025. 11. 17. 오전 9:49
이거 인원수 3명까지인것 같은데 아닌가용 
이미지
Sigrid Jin

 — 2025. 11. 17. 오전 9:49
아 그렇네
저걸 못봣네요
CIlIo — 2025. 11. 17. 오전 9:49
참여하시는분 더 있나요?
Sigrid Jin

 — 2025. 11. 17. 오전 9:50
아 관심잇는 분 잇대서
찾아보다가 인원제한을 알게댐
컷
crab — 2025. 11. 17. 오전 9:51
넵
그럼 일단 포켓몬 rl로 구현해보다 복잡도가 좀 있다 하면 테트리스로 턴해볼까여
Sigrid Jin

 — 2025. 11. 17. 오전 9:53
네네 좋습니다 시간이 잇으니
각자 테스트나 개발 좀 해보고 수요일에 다시 이야기 해볼까요
저도 백그라운드로 개발 돌려노겟슴
crab — 2025. 11. 17. 오전 9:53
옙
Sigrid Jin

 — 2025. 11. 17. 오전 9:53
:elyn_cheek:
CIlIo — 2025. 11. 17. 오전 10:02
진형님 Kv cache말고 또 뭐 생소한데 또 있어보이는 거 찾으신 거 없으신가요? ㅋㅋ
Sigrid Jin

 — 2025. 11. 17. 오전 10:03
떠오르는건 없음 음
CIlIo — 2025. 11. 17. 오전 10:05
암만 생각해도 저런 킥이 하나 있으면 좋아보이는데 Kv Cache 실 사용처 감을 못 잡겠네요
머리를 굴려봐도 너무 진짜 왜 굳이인 요소같아서요
Sigrid Jin

 — 오후 4:43
재가 출장 오늘 돌아가는데 오늘부터 좀 해보겟습닏
@crab 먼가 돌려보신거잇음?
crab — 오후 4:43
넹 좋슴다
아직 해본건 없어용
일단 api부터 받아와서 오늘 밤에 템플릿 느낌으로
레포부터 만들어둘게용
깃헙 조직 하나 만들게용
```

I WANT TO WIN THIS HACKATHON:
```

Qwen SKYST Hackathon on Base by FLock.io
FLock.io
FLock.io is the first decentralized AI training platform combining Federated Learning and blockchain to enable secure, privacy-preserving model training. It empowers communities to collaboratively build and own AI without centralizing data. Powered by the $FLOCK token, FLock drives governance, incentives, and ecosystem growth. Backed by top investors and the Ethereum Foundation, it’s reshaping AI’s future.
🔗 Website | Telegram |  Twitter  
Base 
Base is an Ethereum Layer-2 blockchain network developed by Coinbase. It is designed to improve scalability, performance, and interoperability while reducing transaction costs and settlement time on the Ethereum network. As a decentralized platform, Base supports a wide range of dApps and smart contracts.
🔗 Website | Telegram |  Twitter  
Qwen
Qwen is a family of large language models developed by Alibaba Cloud. Built to understand and generate both Chinese and English, Qwen is designed for a wide range of applications including natural language processing, reasoning, and multimodal tasks. As an open and scalable AI foundation, Qwen powers chatbots, coding assistants, and enterprise solutions across Alibaba’s ecosystem and beyond.
🔗 Website | Linkedin |  Twitter  
🟦 Qwen SKYST Hackathon on Base 개요
Qwen SKYST Hackathon on Base는 Base의 가장 큰 AI 인프라 프로토콜인 FLock.io와 Alibaba Cloud의 Qwen이 Base와 협력하여 주최하는 AI 어플리케이션 해커톤입니다.
베이스의 다채로운 어플리케이션 생태계를 활성화하기 위해서 앱 빌더들을 지원하고 커뮤니티와 공유할 수 있는 기회입니다. 이전 Qwen SKYST Hackathon은 AI 모델을 만드는 데이터톤이었다면, 이번 해커톤은 해당 모델들을 활용하여 실제로 유저들이 활용 가능한 어플리케이션을 Base Mini App 형태로 혹은 x402를 활용한 어플리케이션/AI Agent를 만드는 해커톤입니다.
총 진행 기간: 2025년 11월 21일 - 11월 29일 
해커톤 주제 1: Build an AI Application utilizing FLock.io’s API Platform as a Base Mini App
해커톤 주제 2: Build an AI Application/Agent utilizing FLock.io’s API Platform and x402
🟦  해커톤 소개 및 참가 방법 안내
🪧 해커톤 안내
타임라인
접수 기간: 11월13일 ~ 11월 22일 (선착순 100명 내외로 제한되어 조기 마감될 수 있습니다)
API 지급: 11월 21일 ~ 11월 23일
킥오프: 11월 22일 오후 1시~3시
진행: 온라인(상황에 따라 녹화본 배포로 변경될 수 있음)
온라인 해커톤 진행: 11월 22일~11월 28일 오후 6시
제출 마감 기한은 11월 28일 오후 6시
해커톤 플랫폼 및 결과물 제출 방법은 추후 공지 예정
Top 8 발표 팀 선정: 11월 28일 자정
발표 및 최종 시상식: 11월 29일(토) 오후 2시 ~ 6시
총 상금: $15K
등수
상금
1
$5000
2
$3000
3
$2000
Finalist (4~8)
$1000
📝 해커톤 참가 신청서
한 팀은 총 1~3명으로 구성됩니다
💡 해커톤 주제
✅ 필수 조건
FLock.io의 API Platform의 API를 이용 (OpenAI API 사용하는것과 유사)
다음중 두가지 중에서 하나를 충족
Base Mini App 만들기 
x402 활용한 어플리케이션 혹은 AI Agent 만들기
킥오프에 해당 API 등을 사용하기 위한 간단한 Vibe coding session이 진행될 예정입니다
참고 예시: Vibe Master by FLock.io
데모 영상
웹사이트
✔️ 평가 항목
완성도 (30%)
FLock API 활용도 (30%)
창의성 (20%)
실용성 (20%)
제출 자료:
5분 이내의 프로젝트 설명 및 데모 (영상)
프로젝트 소개 슬라이드, 팀 구성원 소개 (PDF)
프로젝트 설명 (추후 양식 공개 예정)
🟦  행사 정보
해커톤 데모데이 발표 및 시상식 일정: 2025년 11월 29일(토) 오후 2시 ~ 6시
장소: 드림플러스 강남 지하 1층
주최: FLock.io, Base, Alibaba Cloud
참가 대상: Base 및 AI 어플리케이션 개발에 관심 있는 학생, 개발자, 컨텐츠 제작자 등
데모데이 타임라인
14:00~14:30 Registration
14:30~14:45 Closing remarks by FLock.io (Jiahao Sun, CEO)
14:45~15:00 Closing remarks by Base (David, Head of East Asia)
15:00~15:15 Closing remarks by Alibaba Cloud (Stone, Head of Business Development)
15:15~16:30 Top 8 Team 데모 발표
16:30~17:00 Break Time 및 Top Team 최종 심사
17:00~17:15 우승자 발표 및 시상식
17:15~18:00 Networking
🟦 Cooperation Partners
SKYST
SKYST is a consortium of computer clubs from four schools: Seoul National University, Korea University, Yonsei University, KAIST. From 2023, they have been organizing annual hackathons of 100~150 participants, with the purpose of revitalizing the student developer ecosystem and strengthening student developers’ engineering capabilities through collaboration between the four schools.
AIKU [Link]
AIKU is a student-led academic society at Korea University where students interested in studying deep learning come together to engage in education, research, applied projects, and discussions. AIKU was founded in the summer of 2022 by students from the Korea University School of Informatics, under the guidance of Professors Kim Byung-woo and Kim Seung-yong from the Department of Computer Science. Today, it includes students from diverse academic backgrounds.
KUCC [Link]
Korea University Computer Club (KUCC) is the oldest and largest computer club within Korea University, being founded in 1973, through various activities related to computers, KUCC focuses on improving the technical capabilities of individuals and exposing them to various experiences with computers.
YCC [Link]
Yonsei Computer Club (YCC) was founded in 1970 and is the only centralized computer club at Yonsei University. At YCC, students actively participate in full-stack project contests/competitions to gain project experience as it is not only composed of developers but designers and project managers.
SNUAI [Link]
Seoul National University AI Club (SNUAI) is both a university based club and an incorporated startup with an investment of an initial valuation of $250K. Being the only club within Seoul National University that deals with AI in a practical way, they focus on researching and commercializing AI through their own corporation.
Waffle Studio [Link]
Waffle Studio is a web/app service development club based in Seoul National University, School of Computer Science, where it aims to build a community of developers within the department. Founded in 2007 and established as the largest development club on campus, WaffleStudio holds various activities related to development such as projects, studies, and coding meetings. Through projects, they produce development results and contribute to people with useful, experimental, and fun services. Currently, they operate a variety of services that have been launched to students at the university, and have several new projects in the works.
Blockchain Valley @blockchainkor
블록체인밸리는 고려대학교 기반 블록체인 학회입니다. 2022년 3월 1기 출범을 시작으로 현재 54명의 학회원이 개발 팀, 리서치 팀, 보안 팀, 밸리데이터 팀으로 이루어져 활동하고 있습니다. 프로덕트 제작, 리서치 페이퍼 발간, 제로데이 리서치, 코어 리서치, 밸리데이터 운영 중심으로 타 학회 연계 프로젝트, 기업 협력, 아이디어톤 및 해커톤 참여 등 활발한 활동을 이어나가고 있습니다.
BlockBlock @ysblockblock
블록블록은 2022년 9월에 블록체인을 함께 공부하고 싶은 사람들이 모이길 바라며 만들어진 연세대학교 블록체인 동아리입니다. 블록체인에 관심 있는 사람들이 모여 WEB3 산업에 긍정적인 영향을 끼칠 수 있도록 성장 할 수 있는 생태계가 되려 노력합니다. 블록블록은 블록체인의 정신에 맞게 다양한 과의 사람들이 다양한 관점을 가지고 운영해 나가고 있습니다.
CURG @curg_official
CURG는 2018년 서울권 대학을 중심으로 만들어진 블록체인 연합 학회입니다. Tech enthusiast들이 모인 CURG는 3T(Trendy, Thoughtful, Transdisciplinary)의 자세로 블록체인 리서치와 PoC(Proof of Concept) 프로젝트를 수행하고 있습니다. 이를 통해 블록체인의 미래를 앞당기고, 생태계 발전에 기여하는 것을 목표로 하고 있습니다.
Aidenteti Crew @Aidenteti_
2022년에 설립된 아이덴티티 크루는 프로젝트 빌딩 ,해커톤 , 채용 , 해커톤 , 커뮤니티 다 가능한
자유로운 분위기의 빌더들의 놀이터로써 Web3 오프라인 현직/예비 빌더 학회 커뮤니티 입니다.
```

WRITE THE CODE TO WIN
